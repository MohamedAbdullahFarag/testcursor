using Dapper;
using Microsoft.Extensions.Logging;
using Ikhtibar.Infrastructure.Data;
using Ikhtibar.Core.Repositories.Interfaces;
using Ikhtibar.Core.Entities;
using CoreProcessingJobStatus = Ikhtibar.Core.Entities.ProcessingJobStatus;
using CoreProcessingJobType = Ikhtibar.Core.Entities.ProcessingJobType;

namespace Ikhtibar.Infrastructure.Repositories
{
    /// <summary>
    /// Repository implementation for MediaProcessingJob entity using Dapper
    /// Provides comprehensive job management with status tracking and scheduling functionality
    /// </summary>
    public class MediaProcessingJobRepository : BaseRepository<MediaProcessingJob>, IMediaProcessingJobRepository
    {
        private readonly ILogger<MediaProcessingJobRepository> _logger;

        public MediaProcessingJobRepository(IDbConnectionFactory connectionFactory, ILogger<MediaProcessingJobRepository> logger)
            : base(connectionFactory)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Gets jobs for a specific media file
        /// </summary>
        public async Task<IEnumerable<MediaProcessingJob>> GetByMediaFileAsync(Guid mediaFileId, CoreProcessingJobStatus? statusFilter = null, CoreProcessingJobType? jobTypeFilter = null)
        {
            using var scope = _logger.BeginScope("Getting processing jobs for media file {MediaFileId}", mediaFileId);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var whereConditions = new List<string> { "mpj.MediaFileId = @MediaFileId", "mpj.IsDeleted = 0" };
                var parameters = new Dictionary<string, object> { { "MediaFileId", mediaFileId } };

                if (statusFilter.HasValue)
                {
                    whereConditions.Add("mpj.Status = @StatusFilter");
                    parameters["StatusFilter"] = (int)statusFilter.Value;
                }

                if (jobTypeFilter.HasValue)
                {
                    whereConditions.Add("mpj.JobType = @JobTypeFilter");
                    parameters["JobTypeFilter"] = (int)jobTypeFilter.Value;
                }

                var sql = $@"
                    SELECT mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE {string.Join(" AND ", whereConditions)}
                    ORDER BY mpj.CreatedAt DESC";

                var result = await connection.QueryAsync<MediaProcessingJob>(sql, parameters);

                _logger.LogInformation("Retrieved {Count} processing jobs for media file {MediaFileId}", result.Count(), mediaFileId);
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting processing jobs for media file {MediaFileId}", mediaFileId);
                throw;
            }
        }

        /// <summary>
        /// Gets jobs by status
        /// </summary>
        public async Task<IEnumerable<MediaProcessingJob>> GetByStatusAsync(CoreProcessingJobStatus status, int limit = 100, string? orderBy = null)
        {
            using var scope = _logger.BeginScope("Getting processing jobs by status {Status}", status);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var orderClause = orderBy ?? "mpj.Priority DESC, mpj.CreatedAt ASC";

                var sql = $@"
                    SELECT TOP (@Limit) mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE mpj.Status = @Status AND mpj.IsDeleted = 0
                    ORDER BY {orderClause}";

                var result = await connection.QueryAsync<MediaProcessingJob>(sql, new { Status = (int)status, Limit = limit });

                _logger.LogInformation("Retrieved {Count} processing jobs with status {Status}", result.Count(), status);
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting processing jobs by status {Status}", status);
                throw;
            }
        }

        /// <summary>
        /// Gets jobs by type
        /// </summary>
        public async Task<IEnumerable<MediaProcessingJob>> GetByTypeAsync(CoreProcessingJobType jobType, CoreProcessingJobStatus? statusFilter = null, int limit = 100)
        {
            using var scope = _logger.BeginScope("Getting processing jobs by type {JobType}", jobType);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var whereConditions = new List<string> { "mpj.JobType = @JobType", "mpj.IsDeleted = 0" };
                var parameters = new Dictionary<string, object> { { "JobType", (int)jobType }, { "Limit", limit } };

                if (statusFilter.HasValue)
                {
                    whereConditions.Add("mpj.Status = @StatusFilter");
                    parameters["StatusFilter"] = (int)statusFilter.Value;
                }

                var sql = $@"
                    SELECT TOP (@Limit) mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE {string.Join(" AND ", whereConditions)}
                    ORDER BY mpj.Priority DESC, mpj.CreatedAt ASC";

                var result = await connection.QueryAsync<MediaProcessingJob>(sql, parameters);

                _logger.LogInformation("Retrieved {Count} processing jobs with type {JobType}", result.Count(), jobType);
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting processing jobs by type {JobType}", jobType);
                throw;
            }
        }

        /// <summary>
        /// Gets the next job to process from the queue
        /// </summary>
        public async Task<MediaProcessingJob?> GetNextJobAsync(string workerName, IEnumerable<CoreProcessingJobType>? supportedJobTypes = null)
        {
            using var scope = _logger.BeginScope("Getting next job for worker {WorkerName}", workerName);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var whereConditions = new List<string> 
                { 
                    "mpj.Status = @Status", 
                    "mpj.IsDeleted = 0",
                    "(mpj.NextRetryAt IS NULL OR mpj.NextRetryAt <= @CurrentTime)"
                };
                
                var parameters = new Dictionary<string, object> 
                { 
                    { "Status", (int)CoreProcessingJobStatus.Queued }, 
                    { "CurrentTime", DateTime.UtcNow } 
                };

                if (supportedJobTypes != null && supportedJobTypes.Any())
                {
                    var jobTypeList = supportedJobTypes.Select(jt => (int)jt).ToList();
                    whereConditions.Add($"mpj.JobType IN ({string.Join(",", jobTypeList)})");
                }

                var sql = $@"
                    SELECT TOP 1 mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE {string.Join(" AND ", whereConditions)}
                    ORDER BY mpj.Priority DESC, mpj.NextRetryAt ASC, mpj.CreatedAt ASC";

                var result = await connection.QueryFirstOrDefaultAsync<MediaProcessingJob>(sql, parameters);

                if (result != null)
                {
                    _logger.LogInformation("Found next job {JobId} for worker {WorkerName}", result.Id, workerName);
                }
                else
                {
                    _logger.LogDebug("No jobs available for worker {WorkerName}", workerName);
                }

                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting next job for worker {WorkerName}", workerName);
                throw;
            }
        }

        /// <summary>
        /// Gets jobs that are ready for retry
        /// </summary>
        public async Task<IEnumerable<MediaProcessingJob>> GetRetryableJobsAsync(int limit = 50)
        {
            using var scope = _logger.BeginScope("Getting retryable failed jobs");

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    SELECT TOP (@Limit) mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE mpj.Status = @Status 
                      AND mpj.AttemptCount < mpj.MaxAttempts 
                      AND mpj.IsDeleted = 0
                    ORDER BY mpj.Priority DESC, mpj.CompletedAt ASC";

                var result = await connection.QueryAsync<MediaProcessingJob>(sql, new 
                { 
                    Status = (int)CoreProcessingJobStatus.Failed, 
                    Limit = limit 
                });

                _logger.LogInformation("Retrieved {Count} retryable failed jobs", result.Count());
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting retryable failed jobs");
                throw;
            }
        }

        /// <summary>
        /// Gets stuck jobs (processing for too long)
        /// </summary>
        public async Task<IEnumerable<MediaProcessingJob>> GetStuckJobsAsync(int stuckThresholdMinutes = 30, int limit = 100)
        {
            using var scope = _logger.BeginScope("Getting stuck jobs older than {StuckThresholdMinutes} minutes", stuckThresholdMinutes);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var timeoutThreshold = DateTime.UtcNow.AddMinutes(-stuckThresholdMinutes);

                var sql = @"
                    SELECT TOP (@Limit) mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE mpj.Status = @Status 
                      AND mpj.StartedAt <= @TimeoutThreshold
                      AND mpj.IsDeleted = 0
                    ORDER BY mpj.StartedAt ASC";

                var result = await connection.QueryAsync<MediaProcessingJob>(sql, new 
                { 
                    Status = (int)CoreProcessingJobStatus.Processing, 
                    TimeoutThreshold = timeoutThreshold,
                    Limit = limit 
                });

                _logger.LogInformation("Retrieved {Count} stuck jobs older than {StuckThresholdMinutes} minutes", result.Count(), stuckThresholdMinutes);
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting stuck jobs");
                throw;
            }
        }

        /// <summary>
        /// Gets failed jobs that have exceeded max retry attempts
        /// </summary>
        public async Task<IEnumerable<MediaProcessingJob>> GetPermanentlyFailedJobsAsync(int limit = 100)
        {
            using var scope = _logger.BeginScope("Getting permanently failed jobs");

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    SELECT TOP (@Limit) mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE mpj.Status = @Status 
                      AND mpj.IsDeleted = 0
                    ORDER BY mpj.CompletedAt DESC";

                var result = await connection.QueryAsync<MediaProcessingJob>(sql, new 
                { 
                    Status = (int)CoreProcessingJobStatus.FailedPermanently, 
                    Limit = limit 
                });

                _logger.LogInformation("Retrieved {Count} permanently failed jobs", result.Count());
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting permanently failed jobs");
                throw;
            }
        }

        /// <summary>
        /// Gets job statistics by status
        /// </summary>
        public async Task<Dictionary<CoreProcessingJobStatus, int>> GetJobStatsByStatusAsync()
        {
            using var scope = _logger.BeginScope("Getting job statistics by status");

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    SELECT Status, COUNT(*) as JobCount
                    FROM MediaProcessingJobs
                    WHERE IsDeleted = 0
                    GROUP BY Status";

                var results = await connection.QueryAsync<(int Status, int JobCount)>(sql);

                var stats = results.ToDictionary(
                    r => (CoreProcessingJobStatus)r.Status,
                    r => r.JobCount
                );

                _logger.LogInformation("Retrieved job statistics by status");
                return stats;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting job statistics by status");
                throw;
            }
        }

        /// <summary>
        /// Gets job statistics by type
        /// </summary>
        public async Task<Dictionary<CoreProcessingJobType, int>> GetJobStatsByTypeAsync()
        {
            using var scope = _logger.BeginScope("Getting job statistics by type");

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    SELECT JobType, COUNT(*) as JobCount
                    FROM MediaProcessingJobs
                    WHERE IsDeleted = 0
                    GROUP BY JobType";

                var results = await connection.QueryAsync<(int JobType, int JobCount)>(sql);

                var stats = results.ToDictionary(
                    r => (CoreProcessingJobType)r.JobType,
                    r => r.JobCount
                );

                _logger.LogInformation("Retrieved job statistics by type");
                return stats;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting job statistics by type");
                throw;
            }
        }

        /// <summary>
        /// Gets average processing time by job type
        /// </summary>
        public async Task<Dictionary<CoreProcessingJobType, double>> GetAverageProcessingTimeAsync(int days = 30)
        {
            using var scope = _logger.BeginScope("Getting average processing time statistics for last {Days} days", days);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var cutoffDate = DateTime.UtcNow.AddDays(-days);

                var sql = @"
                    SELECT JobType, AVG(CAST(DATEDIFF(MILLISECOND, StartedAt, CompletedAt) as FLOAT)) as AvgProcessingTimeMs
                    FROM MediaProcessingJobs
                    WHERE IsDeleted = 0 
                      AND Status = @CompletedStatus
                      AND StartedAt IS NOT NULL 
                      AND CompletedAt IS NOT NULL
                      AND CompletedAt >= @CutoffDate
                    GROUP BY JobType";

                var results = await connection.QueryAsync<(int JobType, double AvgProcessingTimeMs)>(sql, new 
                { 
                    CompletedStatus = (int)CoreProcessingJobStatus.Completed,
                    CutoffDate = cutoffDate
                });

                var stats = results.ToDictionary(
                    r => (CoreProcessingJobType)r.JobType,
                    r => r.AvgProcessingTimeMs
                );

                _logger.LogInformation("Retrieved average processing time statistics for last {Days} days", days);
                return stats;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting average processing time statistics");
                throw;
            }
        }

        /// <summary>
        /// Gets job throughput statistics
        /// </summary>
        public async Task<Dictionary<DateTime, int>> GetThroughputStatsAsync(int hours = 24)
        {
            using var scope = _logger.BeginScope("Getting throughput statistics for last {Hours} hours", hours);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var cutoffDate = DateTime.UtcNow.AddHours(-hours);

                var sql = @"
                    SELECT 
                        DATEADD(HOUR, DATEDIFF(HOUR, 0, CompletedAt), 0) as HourBucket,
                        COUNT(*) as CompletedJobs
                    FROM MediaProcessingJobs
                    WHERE IsDeleted = 0 
                      AND Status = @CompletedStatus
                      AND CompletedAt >= @CutoffDate
                    GROUP BY DATEADD(HOUR, DATEDIFF(HOUR, 0, CompletedAt), 0)
                    ORDER BY HourBucket";

                var results = await connection.QueryAsync<(DateTime HourBucket, int CompletedJobs)>(sql, new 
                { 
                    CompletedStatus = (int)CoreProcessingJobStatus.Completed,
                    CutoffDate = cutoffDate
                });

                var stats = results.ToDictionary(
                    r => r.HourBucket,
                    r => r.CompletedJobs
                );

                _logger.LogInformation("Retrieved throughput statistics for last {Hours} hours", hours);
                return stats;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting throughput statistics");
                throw;
            }
        }

        /// <summary>
        /// Queues a new processing job
        /// </summary>
        public async Task<MediaProcessingJob> QueueJobAsync(Guid mediaFileId, CoreProcessingJobType jobType, int priority = 5, string? jobParameters = null, int maxAttempts = 3)
        {
            using var scope = _logger.BeginScope("Queueing new job for media file {MediaFileId}, type {JobType}", mediaFileId, jobType);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var job = new MediaProcessingJob
                {
                    Id = Guid.NewGuid(),
                    MediaFileId = mediaFileId,
                    JobType = jobType,
                    Status = CoreProcessingJobStatus.Queued,
                    Priority = priority,
                    AttemptCount = 0,
                    MaxAttempts = maxAttempts,
                    ProgressPercentage = 0,
                    JobParameters = jobParameters,
                    CreatedAt = DateTime.UtcNow,
                    ModifiedAt = DateTime.UtcNow,
                    IsDeleted = false
                };

                var sql = @"
                    INSERT INTO MediaProcessingJobs (Id, MediaFileId, JobType, Status, Priority, JobParameters, 
                                                    MaxAttempts, AttemptCount, ProgressPercentage, CreatedAt, ModifiedAt, IsDeleted)
                    VALUES (@Id, @MediaFileId, @JobType, @Status, @Priority, @JobParameters, 
                            @MaxAttempts, @AttemptCount, @ProgressPercentage, @CreatedAt, @ModifiedAt, @IsDeleted)";

                await connection.ExecuteAsync(sql, new
                {
                    job.Id,
                    job.MediaFileId,
                    JobType = (int)job.JobType,
                    Status = (int)job.Status,
                    job.Priority,
                    job.JobParameters,
                    job.MaxAttempts,
                    job.AttemptCount,
                    job.ProgressPercentage,
                    job.CreatedAt,
                    job.ModifiedAt,
                    job.IsDeleted
                });

                _logger.LogInformation("Queued new job {JobId} for media file {MediaFileId}", job.Id, mediaFileId);
                return job;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error queueing job for media file {MediaFileId}", mediaFileId);
                throw;
            }
        }

        /// <summary>
        /// Marks a job as started
        /// </summary>
        public async Task<bool> MarkJobStartedAsync(Guid jobId, string workerName)
        {
            using var scope = _logger.BeginScope("Marking job {JobId} as started by worker {WorkerName}", jobId, workerName);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    UPDATE MediaProcessingJobs
                    SET Status = @Status,
                        StartedAt = @StartedAt,
                        ProcessedBy = @WorkerName,
                        ProgressPercentage = 0,
                        ModifiedAt = @ModifiedAt
                    WHERE Id = @JobId 
                      AND Status = @QueuedStatus 
                      AND IsDeleted = 0";

                var rowsAffected = await connection.ExecuteAsync(sql, new
                {
                    JobId = jobId,
                    Status = (int)CoreProcessingJobStatus.Processing,
                    QueuedStatus = (int)CoreProcessingJobStatus.Queued,
                    StartedAt = DateTime.UtcNow,
                    WorkerName = workerName,
                    ModifiedAt = DateTime.UtcNow
                });

                var success = rowsAffected > 0;
                if (success)
                {
                    _logger.LogInformation("Job {JobId} marked as started by worker {WorkerName}", jobId, workerName);
                }
                else
                {
                    _logger.LogWarning("Failed to mark job {JobId} as started - job may not be queued or may not exist", jobId);
                }

                return success;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error marking job {JobId} as started", jobId);
                throw;
            }
        }

        /// <summary>
        /// Updates job progress
        /// </summary>
        public async Task<bool> UpdateProgressAsync(Guid jobId, int progressPercentage, string? currentStage = null)
        {
            using var scope = _logger.BeginScope("Updating progress for job {JobId} to {ProgressPercentage}%", jobId, progressPercentage);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var updateFields = new List<string> 
                { 
                    "ProgressPercentage = @ProgressPercentage",
                    "ModifiedAt = @ModifiedAt"
                };
                
                var parameters = new Dictionary<string, object>
                { 
                    { "JobId", jobId },
                    { "ProgressPercentage", Math.Clamp(progressPercentage, 0, 100) },
                    { "ProcessingStatus", (int)CoreProcessingJobStatus.Processing },
                    { "ModifiedAt", DateTime.UtcNow }
                };

                if (!string.IsNullOrEmpty(currentStage))
                {
                    updateFields.Add("ErrorMessage = @CurrentStage");
                    parameters["CurrentStage"] = currentStage;
                }

                var sql = $@"
                    UPDATE MediaProcessingJobs
                    SET {string.Join(", ", updateFields)}
                    WHERE Id = @JobId 
                      AND Status = @ProcessingStatus 
                      AND IsDeleted = 0";

                var rowsAffected = await connection.ExecuteAsync(sql, parameters);

                var success = rowsAffected > 0;
                if (success)
                {
                    _logger.LogDebug("Job {JobId} progress updated to {ProgressPercentage}%", jobId, progressPercentage);
                }
                else
                {
                    _logger.LogWarning("Failed to update progress for job {JobId} - job may not be processing or may not exist", jobId);
                }

                return success;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating progress for job {JobId}", jobId);
                throw;
            }
        }

        /// <summary>
        /// Marks a job as completed successfully
        /// </summary>
        public async Task<bool> MarkJobCompletedAsync(Guid jobId, string? jobResults = null, long? processingDurationMs = null)
        {
            using var scope = _logger.BeginScope("Marking job {JobId} as completed", jobId);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    UPDATE MediaProcessingJobs
                    SET Status = @Status,
                        CompletedAt = @CompletedAt,
                        ProgressPercentage = 100,
                        ErrorMessage = @JobResults,
                        ModifiedAt = @ModifiedAt
                    WHERE Id = @JobId 
                      AND Status = @ProcessingStatus 
                      AND IsDeleted = 0";

                var rowsAffected = await connection.ExecuteAsync(sql, new
                {
                    JobId = jobId,
                    Status = (int)CoreProcessingJobStatus.Completed,
                    ProcessingStatus = (int)CoreProcessingJobStatus.Processing,
                    CompletedAt = DateTime.UtcNow,
                    JobResults = jobResults,
                    ModifiedAt = DateTime.UtcNow
                });

                var success = rowsAffected > 0;
                if (success)
                {
                    _logger.LogInformation("Job {JobId} marked as completed successfully", jobId);
                }
                else
                {
                    _logger.LogWarning("Failed to mark job {JobId} as completed - job may not be processing or may not exist", jobId);
                }

                return success;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error marking job {JobId} as completed", jobId);
                throw;
            }
        }

        /// <summary>
        /// Marks a job as failed
        /// </summary>
        public async Task<bool> MarkJobFailedAsync(Guid jobId, string errorMessage, string? errorStackTrace = null, int? retryAfterMinutes = null)
        {
            using var scope = _logger.BeginScope("Marking job {JobId} as failed", jobId);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var errorDetails = errorMessage;
                if (!string.IsNullOrEmpty(errorStackTrace))
                {
                    errorDetails += Environment.NewLine + "Stack Trace:" + Environment.NewLine + errorStackTrace;
                }

                var nextScheduleTime = retryAfterMinutes.HasValue ? DateTime.UtcNow.AddMinutes(retryAfterMinutes.Value) : (DateTime?)null;

                var sql = @"
                    UPDATE MediaProcessingJobs
                    SET Status = @Status,
                        CompletedAt = @CompletedAt,
                        ErrorMessage = @ErrorMessage,
                        AttemptCount = AttemptCount + 1,
                        NextRetryAt = @NextScheduleTime,
                        ModifiedAt = @ModifiedAt
                    WHERE Id = @JobId 
                      AND Status = @ProcessingStatus 
                      AND IsDeleted = 0";

                var rowsAffected = await connection.ExecuteAsync(sql, new
                {
                    JobId = jobId,
                    Status = (int)CoreProcessingJobStatus.Failed,
                    ProcessingStatus = (int)CoreProcessingJobStatus.Processing,
                    CompletedAt = DateTime.UtcNow,
                    ErrorMessage = errorDetails,
                    NextScheduleTime = nextScheduleTime,
                    ModifiedAt = DateTime.UtcNow
                });

                var success = rowsAffected > 0;
                if (success)
                {
                    _logger.LogWarning("Job {JobId} marked as failed: {ErrorMessage}", jobId, errorMessage);
                }
                else
                {
                    _logger.LogWarning("Failed to mark job {JobId} as failed - job may not be processing or may not exist", jobId);
                }

                return success;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error marking job {JobId} as failed", jobId);
                throw;
            }
        }

        /// <summary>
        /// Cancels a job
        /// </summary>
        public async Task<bool> CancelJobAsync(Guid jobId, string? reason = null)
        {
            using var scope = _logger.BeginScope("Cancelling job {JobId}", jobId);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    UPDATE MediaProcessingJobs
                    SET Status = @Status,
                        CompletedAt = @CompletedAt,
                        ErrorMessage = @Reason,
                        ModifiedAt = @ModifiedAt
                    WHERE Id = @JobId 
                      AND Status IN (@QueuedStatus, @ProcessingStatus)
                      AND IsDeleted = 0";

                var rowsAffected = await connection.ExecuteAsync(sql, new
                {
                    JobId = jobId,
                    Status = (int)CoreProcessingJobStatus.Cancelled,
                    QueuedStatus = (int)CoreProcessingJobStatus.Queued,
                    ProcessingStatus = (int)CoreProcessingJobStatus.Processing,
                    CompletedAt = DateTime.UtcNow,
                    Reason = reason ?? "Job cancelled by user",
                    ModifiedAt = DateTime.UtcNow
                });

                var success = rowsAffected > 0;
                if (success)
                {
                    _logger.LogInformation("Job {JobId} cancelled: {Reason}", jobId, reason ?? "No reason provided");
                }
                else
                {
                    _logger.LogWarning("Failed to cancel job {JobId} - job may not be queued/processing or may not exist", jobId);
                }

                return success;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error cancelling job {JobId}", jobId);
                throw;
            }
        }

        /// <summary>
        /// Resets stuck jobs back to queued status
        /// </summary>
        public async Task<int> ResetStuckJobsAsync(int stuckThresholdMinutes = 30)
        {
            using var scope = _logger.BeginScope("Resetting stuck jobs older than {StuckThresholdMinutes} minutes", stuckThresholdMinutes);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var timeoutThreshold = DateTime.UtcNow.AddMinutes(-stuckThresholdMinutes);

                var sql = @"
                    UPDATE MediaProcessingJobs
                    SET Status = @QueuedStatus,
                        StartedAt = NULL,
                        ProgressPercentage = 0,
                        ProcessedBy = NULL,
                        ErrorMessage = @ErrorMessage,
                        ModifiedAt = @ModifiedAt
                    WHERE Status = @ProcessingStatus 
                      AND StartedAt <= @TimeoutThreshold
                      AND IsDeleted = 0";

                var rowsAffected = await connection.ExecuteAsync(sql, new
                {
                    QueuedStatus = (int)CoreProcessingJobStatus.Queued,
                    ProcessingStatus = (int)CoreProcessingJobStatus.Processing,
                    TimeoutThreshold = timeoutThreshold,
                    ErrorMessage = $"Job reset due to timeout (exceeded {stuckThresholdMinutes} minutes)",
                    ModifiedAt = DateTime.UtcNow
                });

                _logger.LogInformation("Reset {Count} stuck jobs older than {StuckThresholdMinutes} minutes", rowsAffected, stuckThresholdMinutes);
                return rowsAffected;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resetting stuck jobs");
                throw;
            }
        }

        /// <summary>
        /// Bulk updates job priority
        /// </summary>
        public async Task<int> BulkUpdatePriorityAsync(IEnumerable<Guid> jobIds, int newPriority)
        {
            using var scope = _logger.BeginScope("Updating job priorities in bulk");

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();
                using var transaction = connection.BeginTransaction();

                try
                {
                    var updatedCount = 0;

                    foreach (var jobId in jobIds)
                    {
                        var sql = @"
                            UPDATE MediaProcessingJobs
                            SET Priority = @Priority,
                                ModifiedAt = @ModifiedAt
                            WHERE Id = @JobId AND IsDeleted = 0";

                        var rowsAffected = await connection.ExecuteAsync(sql, new
                        {
                            JobId = jobId,
                            Priority = newPriority,
                            ModifiedAt = DateTime.UtcNow
                        }, transaction);

                        updatedCount += rowsAffected;
                    }

                    transaction.Commit();

                    _logger.LogInformation("Updated priorities for {UpdatedCount} jobs", updatedCount);
                    return updatedCount;
                }
                catch
                {
                    transaction.Rollback();
                    throw;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating job priorities in bulk");
                throw;
            }
        }

        /// <summary>
        /// Deletes old completed/failed jobs
        /// </summary>
        public async Task<int> CleanupOldJobsAsync(int olderThanDays = 30, bool keepFailed = true)
        {
            using var scope = _logger.BeginScope("Cleaning up jobs older than {Days} days", olderThanDays);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var cutoffDate = DateTime.UtcNow.AddDays(-olderThanDays);
                var statusList = new List<int> { (int)CoreProcessingJobStatus.Completed, (int)CoreProcessingJobStatus.Cancelled };

                if (!keepFailed)
                {
                    statusList.Add((int)CoreProcessingJobStatus.Failed);
                    statusList.Add((int)CoreProcessingJobStatus.FailedPermanently);
                }

                var sql = $@"
                    DELETE FROM MediaProcessingJobs
                    WHERE Status IN ({string.Join(",", statusList)})
                      AND CompletedAt <= @CutoffDate
                      AND IsDeleted = 0";

                var rowsAffected = await connection.ExecuteAsync(sql, new { CutoffDate = cutoffDate });

                _logger.LogInformation("Cleaned up {Count} old jobs older than {Days} days", rowsAffected, olderThanDays);
                return rowsAffected;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error cleaning up old jobs");
                throw;
            }
        }

        /// <summary>
        /// Gets jobs processed by a specific worker
        /// </summary>
        public async Task<IEnumerable<MediaProcessingJob>> GetByWorkerAsync(string workerName, CoreProcessingJobStatus? statusFilter = null, int limit = 100)
        {
            using var scope = _logger.BeginScope("Getting jobs processed by worker {WorkerName}", workerName);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var whereConditions = new List<string> { "mpj.ProcessedBy = @WorkerName", "mpj.IsDeleted = 0" };
                var parameters = new Dictionary<string, object> { { "WorkerName", workerName }, { "Limit", limit } };

                if (statusFilter.HasValue)
                {
                    whereConditions.Add("mpj.Status = @StatusFilter");
                    parameters["StatusFilter"] = (int)statusFilter.Value;
                }

                var sql = $@"
                    SELECT TOP (@Limit) mpj.Id, mpj.MediaFileId, mpj.JobType, mpj.Status, mpj.Priority, mpj.StartedAt, 
                           mpj.CompletedAt, mpj.ProgressPercentage, mpj.ErrorMessage, mpj.AttemptCount, 
                           mpj.MaxAttempts, mpj.NextRetryAt, mpj.ProcessedBy, mpj.JobParameters, 
                           mpj.CreatedAt, mpj.ModifiedAt, mpj.IsDeleted, mpj.DeletedAt, mpj.RowVersion
                    FROM MediaProcessingJobs mpj
                    WHERE {string.Join(" AND ", whereConditions)}
                    ORDER BY mpj.StartedAt DESC";

                var result = await connection.QueryAsync<MediaProcessingJob>(sql, parameters);

                _logger.LogInformation("Retrieved {Count} jobs processed by worker {WorkerName}", result.Count(), workerName);
                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting jobs processed by worker {WorkerName}", workerName);
                throw;
            }
        }

        /// <summary>
        /// Gets job queue depth by priority
        /// </summary>
        public async Task<Dictionary<int, int>> GetQueueDepthByPriorityAsync()
        {
            using var scope = _logger.BeginScope("Getting job queue depth by priority");

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var sql = @"
                    SELECT Priority, COUNT(*) as JobCount
                    FROM MediaProcessingJobs
                    WHERE Status = @QueuedStatus AND IsDeleted = 0
                    GROUP BY Priority
                    ORDER BY Priority DESC";

                var results = await connection.QueryAsync<(int Priority, int JobCount)>(sql, new 
                { 
                    QueuedStatus = (int)CoreProcessingJobStatus.Queued 
                });

                var stats = results.ToDictionary(r => r.Priority, r => r.JobCount);

                _logger.LogInformation("Retrieved job queue depth by priority");
                return stats;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting job queue depth by priority");
                throw;
            }
        }

        /// <summary>
        /// Checks if there are any pending jobs for a media file
        /// </summary>
        public async Task<bool> HasPendingJobsAsync(Guid mediaFileId, CoreProcessingJobType? jobType = null)
        {
            using var scope = _logger.BeginScope("Checking for pending jobs for media file {MediaFileId}", mediaFileId);

            try
            {
                using var connection = await _connectionFactory.CreateConnectionAsync();

                var whereConditions = new List<string> 
                { 
                    "MediaFileId = @MediaFileId", 
                    "Status IN (@QueuedStatus, @ProcessingStatus)", 
                    "IsDeleted = 0" 
                };
                
                var parameters = new Dictionary<string, object>
                { 
                    { "MediaFileId", mediaFileId },
                    { "QueuedStatus", (int)CoreProcessingJobStatus.Queued },
                    { "ProcessingStatus", (int)CoreProcessingJobStatus.Processing }
                };                if (jobType.HasValue)
                {
                    whereConditions.Add("JobType = @JobType");
                    parameters["JobType"] = (int)jobType.Value;
                }

                var sql = $@"
                    SELECT COUNT(*)
                    FROM MediaProcessingJobs
                    WHERE {string.Join(" AND ", whereConditions)}";

                var count = await connection.QuerySingleAsync<int>(sql, parameters);
                var hasPendingJobs = count > 0;

                _logger.LogDebug("Media file {MediaFileId} has {Count} pending jobs", mediaFileId, count);
                return hasPendingJobs;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking for pending jobs for media file {MediaFileId}", mediaFileId);
                throw;
            }
        }
    }
}
