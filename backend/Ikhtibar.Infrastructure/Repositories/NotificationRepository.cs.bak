using Dapper;
using Ikhtibar.Shared.Entities;
using Ikhtibar.Shared.Models;
using Ikhtibar.Shared.Enums;
using Ikhtibar.Core.Repositories.Interfaces;
using Ikhtibar.Infrastructure.Data;

namespace Ikhtibar.Infrastructure.Repositories;

/// <summary>
/// Notification repository implementation using Dapper
/// Provides notification-specific data access operations following established patterns
/// </summary>
public class NotificationRepository : BaseRepository<Notification>, INotificationRepository
{
    /// <summary>
    /// Initializes a new instance of the NotificationRepository
    /// </summary>
    /// <param name="connectionFactory">Factory for creating database connections</param>
    public NotificationRepository(IDbConnectionFactory connectionFactory) : base(connectionFactory)
    {
    }

    /// <summary>
    /// Gets notifications for a specific user with pagination
    /// </summary>
    /// <param name="userId">Target user ID</param>
    /// <param name="page">Page number (1-based)</param>
    /// <param name="pageSize">Number of notifications per page</param>
    /// <param name="unreadOnly">If true, returns only unread notifications</param>
    /// <param name="notificationType">Optional filter by notification type</param>
    /// <returns>Paginated list of notifications for the user</returns>
    public async Task<(IEnumerable<Notification> Notifications, int TotalCount)> GetUserNotificationsAsync(
        int userId, 
        int page = 1, 
        int pageSize = 20, 
        bool unreadOnly = false,
        NotificationType? notificationType = null)
    {
        var offset = (page - 1) * pageSize;
        var whereConditions = "UserId = @UserId AND IsDeleted = 0";
        var parameters = new DynamicParameters();
        parameters.Add("@UserId", userId);
        parameters.Add("@Offset", offset);
        parameters.Add("@PageSize", pageSize);

        if (unreadOnly)
        {
            whereConditions += " AND IsRead = 0";
        }

        if (notificationType.HasValue)
        {
            whereConditions += " AND NotificationType = @NotificationType";
            parameters.Add("@NotificationType", notificationType.Value);
        }

        const string countSql = @"
            SELECT COUNT(1) 
            FROM Notifications 
            WHERE {0}";

        const string dataSql = @"
            SELECT * 
            FROM Notifications 
            WHERE {0}
            ORDER BY CreatedAt DESC, Priority DESC 
            OFFSET @offset ROWS FETCH NEXT @pageSize ROWS ONLY";

        using var connection = _connectionFactory.CreateConnection();

        // Get total count
        var totalCount = await connection.QuerySingleAsync<int>(
            string.Format(countSql, whereConditions),
            parameters);

        // Get data
        var notifications = await connection.QueryAsync<Notification>(
            string.Format(dataSql, whereConditions),
            parameters);

        return (notifications, totalCount);
    }

    /// <summary>
    /// Gets count of unread notifications for a user
    /// </summary>
    /// <param name="userId">Target user ID</param>
    /// <returns>Number of unread notifications</returns>
    public async Task<int> GetUnreadCountAsync(int userId)
    {
        const string sql = @"
            SELECT COUNT(1) 
            FROM Notifications 
            WHERE UserId = @UserId AND IsRead = 0 AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QuerySingleAsync<int>(sql, new { UserId = userId });
    }

    /// <summary>
    /// Gets notification by ID including user information
    /// </summary>
    /// <param name="notificationId">Notification ID</param>
    /// <returns>Notification with user details if found</returns>
    public async Task<Notification?> GetByIdWithUserAsync(Guid notificationId)
    {
        const string sql = @"
            SELECT n.*, u.Id as UserId, u.Email, u.FirstName, u.LastName
            FROM Notifications n
            INNER JOIN Users u ON n.UserId = u.Id
            WHERE n.Id = @NotificationId AND n.IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QueryFirstOrDefaultAsync<Notification>(sql, new { NotificationId = notificationId });
    }

    /// <summary>
    /// Marks a notification as read
    /// </summary>
    /// <param name="notificationId">Notification ID</param>
    /// <param name="userId">User ID for authorization</param>
    /// <returns>True if successfully marked as read</returns>
    public async Task<bool> MarkAsReadAsync(Guid notificationId, int userId)
    {
        const string sql = @"
            UPDATE Notifications 
            SET IsRead = 1, ReadAt = @ReadAt, ModifiedAt = @ModifiedAt
            WHERE Id = @NotificationId AND UserId = @UserId AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        var affectedRows = await connection.ExecuteAsync(sql, new 
        { 
            NotificationId = notificationId, 
            UserId = userId,
            ReadAt = DateTime.UtcNow,
            ModifiedAt = DateTime.UtcNow
        });

        return affectedRows > 0;
    }

    /// <summary>
    /// Marks all notifications as read for a user
    /// </summary>
    /// <param name="userId">Target user ID</param>
    /// <returns>Number of notifications marked as read</returns>
    public async Task<int> MarkAllAsReadAsync(int userId)
    {
        const string sql = @"
            UPDATE Notifications 
            SET IsRead = 1, ReadAt = @ReadAt, ModifiedAt = @ModifiedAt
            WHERE UserId = @UserId AND IsRead = 0 AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.ExecuteAsync(sql, new 
        { 
            UserId = userId,
            ReadAt = DateTime.UtcNow,
            ModifiedAt = DateTime.UtcNow
        });
    }

    /// <summary>
    /// Gets pending notifications that are ready to be sent
    /// </summary>
    /// <param name="batchSize">Maximum number of notifications to return</param>
    /// <returns>List of notifications ready for processing</returns>
    public async Task<IEnumerable<Notification>> GetPendingNotificationsAsync(int batchSize = 100)
    {
        const string sql = @"
            SELECT * 
            FROM Notifications 
            WHERE Status = @Status AND IsDeleted = 0
            ORDER BY Priority DESC, CreatedAt ASC
            LIMIT @BatchSize";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QueryAsync<Notification>(sql, new 
        { 
            Status = NotificationStatus.Pending,
            BatchSize = batchSize
        });
    }

    /// <summary>
    /// Gets notifications scheduled for future delivery that are now due
    /// </summary>
    /// <param name="batchSize">Maximum number of notifications to return</param>
    /// <returns>List of scheduled notifications that are due</returns>
    public async Task<IEnumerable<Notification>> GetDueScheduledNotificationsAsync(int batchSize = 100)
    {
        const string sql = @"
            SELECT * 
            FROM Notifications 
            WHERE Status = @Status 
                AND ScheduledAt IS NOT NULL 
                AND ScheduledAt <= @CurrentTime 
                AND IsDeleted = 0
            ORDER BY Priority DESC, ScheduledAt ASC
            LIMIT @BatchSize";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QueryAsync<Notification>(sql, new 
        { 
            Status = NotificationStatus.Scheduled,
            CurrentTime = DateTime.UtcNow,
            BatchSize = batchSize
        });
    }

    /// <summary>
    /// Updates notification status
    /// </summary>
    /// <param name="notificationId">Notification ID</param>
    /// <param name="status">New status</param>
    /// <param name="sentAt">Optional sent timestamp</param>
    /// <returns>True if successfully updated</returns>
    public async Task<bool> UpdateStatusAsync(Guid notificationId, NotificationStatus status, DateTime? sentAt = null)
    {
        var sql = @"
            UPDATE Notifications 
            SET Status = @Status, ModifiedAt = @ModifiedAt";

        var parameters = new DynamicParameters();
        parameters.Add("@NotificationId", notificationId);
        parameters.Add("@Status", status);
        parameters.Add("@ModifiedAt", DateTime.UtcNow);

        if (sentAt.HasValue)
        {
            sql += ", SentAt = @SentAt";
            parameters.Add("@SentAt", sentAt.Value);
        }

        sql += " WHERE Id = @NotificationId AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        var affectedRows = await connection.ExecuteAsync(sql, parameters);

        return affectedRows > 0;
    }

    /// <summary>
    /// Gets notifications by entity reference (e.g., all notifications for an exam)
    /// </summary>
    /// <param name="entityType">Entity type (e.g., "Exam", "User")</param>
    /// <param name="entityId">Entity ID</param>
    /// <returns>List of notifications related to the entity</returns>
    public async Task<IEnumerable<Notification>> GetByEntityAsync(string entityType, int entityId)
    {
        const string sql = @"
            SELECT * 
            FROM Notifications 
            WHERE EntityType = @EntityType AND EntityId = @EntityId AND IsDeleted = 0
            ORDER BY CreatedAt DESC";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QueryAsync<Notification>(sql, new 
        { 
            EntityType = entityType,
            EntityId = entityId
        });
    }

    /// <summary>
    /// Gets notification statistics for a user within a date range
    /// </summary>
    /// <param name="userId">Target user ID</param>
    /// <param name="fromDate">Start date for statistics</param>
    /// <param name="toDate">End date for statistics</param>
    /// <returns>Statistics including total, read, unread counts by type</returns>
    public async Task<NotificationStats> GetUserStatsAsync(int userId, DateTime fromDate, DateTime toDate)
    {
        const string totalSql = @"
            SELECT COUNT(1) 
            FROM Notifications 
            WHERE UserId = @UserId AND CreatedAt BETWEEN @FromDate AND @ToDate AND IsDeleted = 0";

        const string readSql = @"
            SELECT COUNT(1) 
            FROM Notifications 
            WHERE UserId = @UserId AND IsRead = 1 AND CreatedAt BETWEEN @FromDate AND @ToDate AND IsDeleted = 0";

        const string byTypeSql = @"
            SELECT NotificationType, COUNT(1) as Count
            FROM Notifications 
            WHERE UserId = @UserId AND CreatedAt BETWEEN @FromDate AND @ToDate AND IsDeleted = 0
            GROUP BY NotificationType";

        const string byChannelSql = @"
            SELECT JSON_EXTRACT(ChannelData, '$.channel') as Channel, COUNT(1) as Count
            FROM Notifications 
            WHERE UserId = @UserId AND CreatedAt BETWEEN @FromDate AND @ToDate AND IsDeleted = 0
            GROUP BY JSON_EXTRACT(ChannelData, '$.channel')";

        var parameters = new { UserId = userId, FromDate = fromDate, ToDate = toDate };

        using var connection = _connectionFactory.CreateConnection();

        var total = await connection.QuerySingleAsync<int>(totalSql, parameters);
        var read = await connection.QuerySingleAsync<int>(readSql, parameters);
        var byType = await connection.QueryAsync<(NotificationType Type, int Count)>(byTypeSql, parameters);
        var byChannel = await connection.QueryAsync<(string Channel, int Count)>(byChannelSql, parameters);

        var stats = new NotificationStats
        {
            TotalNotifications = total,
            ReadNotifications = read,
            UnreadNotifications = total - read
        };

        foreach (var (type, count) in byType)
        {
            stats.NotificationsByType[type] = count;
        }

        foreach (var (channel, count) in byChannel)
        {
            if (Enum.TryParse<NotificationChannel>(channel, out var channelEnum))
            {
                stats.NotificationsByChannel[channelEnum] = count;
            }
        }

        return stats;
    }

    /// <summary>
    /// Deletes old read notifications beyond retention period
    /// </summary>
    /// <param name="retentionDays">Number of days to retain read notifications</param>
    /// <returns>Number of notifications deleted</returns>
    public async Task<int> CleanupOldNotificationsAsync(int retentionDays = 90)
    {
        const string sql = @"
            UPDATE Notifications 
            SET IsDeleted = 1, ModifiedAt = @ModifiedAt
            WHERE IsRead = 1 
                AND CreatedAt < @CutoffDate 
                AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.ExecuteAsync(sql, new 
        { 
            CutoffDate = DateTime.UtcNow.AddDays(-retentionDays),
            ModifiedAt = DateTime.UtcNow
        });
    }
}
