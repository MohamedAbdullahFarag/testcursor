using Dapper;
using Ikhtibar.Shared.Entities;
using Ikhtibar.Shared.Models;
using Ikhtibar.Core.Repositories.Interfaces;
using Ikhtibar.Infrastructure.Data;
using Ikhtibar.Shared.Enums;

namespace Ikhtibar.Infrastructure.Repositories;

/// <summary>
/// Notification history repository implementation using Dapper
/// Provides delivery tracking and analytics data access operations following established patterns
/// </summary>
public class NotificationHistoryRepository : BaseRepository<NotificationHistory>, INotificationHistoryRepository
{
    /// <summary>
    /// Initializes a new instance of the NotificationHistoryRepository
    /// </summary>
    /// <param name="connectionFactory">Factory for creating database connections</param>
    public NotificationHistoryRepository(IDbConnectionFactory connectionFactory) : base(connectionFactory)
    {
    }

    /// <summary>
    /// Gets delivery history for a specific notification
    /// </summary>
    /// <param name="notificationId">Notification ID</param>
    /// <returns>List of delivery attempts for the notification</returns>
    public async Task<IEnumerable<NotificationHistory>> GetByNotificationIdAsync(Guid notificationId)
    {
        const string sql = @"
            SELECT * 
            FROM NotificationHistory 
            WHERE NotificationId = @NotificationId AND IsDeleted = 0
            ORDER BY AttemptedAt DESC";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QueryAsync<NotificationHistory>(sql, new { NotificationId = notificationId });
    }

    /// <summary>
    /// Gets delivery history by channel within a date range
    /// </summary>
    /// <param name="channel">Delivery channel</param>
    /// <param name="fromDate">Start date</param>
    /// <param name="toDate">End date</param>
    /// <param name="limit">Maximum number of records</param>
    /// <returns>List of delivery history records</returns>
    public async Task<IEnumerable<NotificationHistory>> GetByChannelAsync(NotificationChannel channel, DateTime fromDate, DateTime toDate, int limit = 1000)
    {
        const string sql = @"
            SELECT * 
            FROM NotificationHistory 
            WHERE Channel = @Channel 
                AND AttemptedAt BETWEEN @FromDate AND @ToDate 
                AND IsDeleted = 0
            ORDER BY AttemptedAt DESC
            LIMIT @Limit";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QueryAsync<NotificationHistory>(sql, new 
        { 
            Channel = channel,
            FromDate = fromDate,
            ToDate = toDate,
            Limit = limit
        });
    }

    /// <summary>
    /// Gets failed delivery attempts for retry processing
    /// </summary>
    /// <param name="maxRetryAttempts">Maximum number of retry attempts allowed</param>
    /// <param name="retryDelayMinutes">Minimum delay between retry attempts</param>
    /// <param name="batchSize">Maximum number of records to return</param>
    /// <returns>List of failed deliveries eligible for retry</returns>
    public async Task<IEnumerable<NotificationHistory>> GetFailedDeliveriesForRetryAsync(int maxRetryAttempts = 3, int retryDelayMinutes = 30, int batchSize = 100)
    {
        const string sql = @"
            SELECT nh.* 
            FROM NotificationHistory nh
            INNER JOIN Notifications n ON nh.NotificationId = n.Id
            WHERE nh.Status = @FailedStatus
                AND nh.RetryCount < @MaxRetryAttempts
                AND nh.AttemptedAt < @RetryAfter
                AND nh.IsDeleted = 0
                AND n.IsDeleted = 0
            ORDER BY nh.Priority DESC, nh.AttemptedAt ASC
            LIMIT @BatchSize";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.QueryAsync<NotificationHistory>(sql, new 
        { 
            FailedStatus = NotificationDeliveryStatus.Failed,
            MaxRetryAttempts = maxRetryAttempts,
            RetryAfter = DateTime.UtcNow.AddMinutes(-retryDelayMinutes),
            BatchSize = batchSize
        });
    }

    /// <summary>
    /// Updates delivery status for an existing history record
    /// </summary>
    /// <param name="historyId">History record ID</param>
    /// <param name="status">New delivery status</param>
    /// <param name="deliveredAt">Delivery timestamp</param>
    /// <param name="responseData">Updated response data</param>
    /// <returns>True if successfully updated</returns>
    public async Task<bool> UpdateDeliveryStatusAsync(Guid historyId, NotificationDeliveryStatus status, DateTime? deliveredAt = null, string? responseData = null)
    {
        var sql = @"
            UPDATE NotificationHistory 
            SET 
                Status = @Status,
                ResponseData = @ResponseData,
                ModifiedAt = @ModifiedAt";

        var parameters = new DynamicParameters();
        parameters.Add("@HistoryId", historyId);
        parameters.Add("@Status", status);
        parameters.Add("@ResponseData", responseData);
        parameters.Add("@ModifiedAt", DateTime.UtcNow);

        if (deliveredAt.HasValue)
        {
            sql += ", DeliveredAt = @DeliveredAt";
            parameters.Add("@DeliveredAt", deliveredAt.Value);
        }

        sql += " WHERE Id = @HistoryId AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        var affectedRows = await connection.ExecuteAsync(sql, parameters);

        return affectedRows > 0;
    }

    /// <summary>
    /// Increments retry count for a delivery attempt
    /// </summary>
    /// <param name="historyId">History record ID</param>
    /// <returns>True if successfully updated</returns>
    public async Task<bool> IncrementRetryCountAsync(Guid historyId)
    {
        const string sql = @"
            UPDATE NotificationHistory 
            SET 
                RetryCount = RetryCount + 1,
                ModifiedAt = @ModifiedAt
            WHERE Id = @HistoryId AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        var affectedRows = await connection.ExecuteAsync(sql, new 
        { 
            HistoryId = historyId,
            ModifiedAt = DateTime.UtcNow
        });

        return affectedRows > 0;
    }

    /// <summary>
    /// Gets delivery analytics within a date range
    /// </summary>
    /// <param name="fromDate">Start date for analytics</param>
    /// <param name="toDate">End date for analytics</param>
    /// <returns>Comprehensive delivery analytics</returns>
    public async Task<DeliveryAnalytics> GetDeliveryAnalyticsAsync(DateTime fromDate, DateTime toDate)
    {
        const string overallSql = @"
            SELECT 
                COUNT(*) as TotalAttempts,
                COUNT(CASE WHEN DeliveryStatus = @DeliveredStatus THEN 1 END) as SuccessfulDeliveries,
                COUNT(CASE WHEN DeliveryStatus = @FailedStatus THEN 1 END) as FailedDeliveries,
                COUNT(CASE WHEN DeliveryStatus = @PendingStatus THEN 1 END) as PendingDeliveries,
                AVG(CASE WHEN DeliveredAt IS NOT NULL AND AttemptedAt IS NOT NULL 
                    THEN (julianday(DeliveredAt) - julianday(AttemptedAt)) * 86400 END) as AvgDeliveryTimeSeconds,
                SUM(COALESCE(Cost, 0)) as TotalCost
            FROM NotificationHistory 
            WHERE AttemptedAt BETWEEN @FromDate AND @ToDate 
                AND IsDeleted = 0";

        const string byChannelSql = @"
            SELECT 
                Channel,
                COUNT(*) as TotalAttempts,
                COUNT(CASE WHEN DeliveryStatus = @DeliveredStatus THEN 1 END) as SuccessfulDeliveries,
                COUNT(CASE WHEN DeliveryStatus = @FailedStatus THEN 1 END) as FailedDeliveries,
                AVG(CASE WHEN DeliveredAt IS NOT NULL AND AttemptedAt IS NOT NULL 
                    THEN (julianday(DeliveredAt) - julianday(AttemptedAt)) * 86400 END) as AvgDeliveryTimeSeconds,
                SUM(COALESCE(Cost, 0)) as TotalCost
            FROM NotificationHistory 
            WHERE AttemptedAt BETWEEN @FromDate AND @ToDate 
                AND IsDeleted = 0
            GROUP BY Channel";

        const string byHourSql = @"
            SELECT 
                strftime('%H', AttemptedAt) as Hour,
                COUNT(*) as TotalAttempts,
                COUNT(CASE WHEN DeliveryStatus = @DeliveredStatus THEN 1 END) as SuccessfulDeliveries
            FROM NotificationHistory 
            WHERE AttemptedAt BETWEEN @FromDate AND @ToDate 
                AND IsDeleted = 0
            GROUP BY strftime('%H', AttemptedAt)
            ORDER BY Hour";

        const string topErrorsSql = @"
            SELECT 
                ErrorMessage,
                COUNT(*) as ErrorCount,
                Channel
            FROM NotificationHistory 
            WHERE AttemptedAt BETWEEN @FromDate AND @ToDate 
                AND DeliveryStatus = @FailedStatus
                AND ErrorMessage IS NOT NULL
                AND IsDeleted = 0
            GROUP BY ErrorMessage, Channel
            ORDER BY ErrorCount DESC
            LIMIT 10";

        var parameters = new 
        { 
            FromDate = fromDate,
            ToDate = toDate,
            DeliveredStatus = NotificationDeliveryStatus.Delivered,
            FailedStatus = NotificationDeliveryStatus.Failed,
            PendingStatus = NotificationDeliveryStatus.Pending
        };

        using var connection = _connectionFactory.CreateConnection();

        var overall = await connection.QueryFirstOrDefaultAsync<OverallDeliveryStats>(overallSql, parameters);
        var byChannel = await connection.QueryAsync<ChannelDeliveryStats>(byChannelSql, parameters);
        var byHour = await connection.QueryAsync<HourlyDeliveryStats>(byHourSql, parameters);
        var topErrors = await connection.QueryAsync<ErrorStats>(topErrorsSql, parameters);

        return new DeliveryAnalytics
        {
            PeriodStart = fromDate,
            PeriodEnd = toDate,
            Overall = overall ?? new OverallDeliveryStats(),
            ByChannel = byChannel.ToList(),
            ByHour = byHour.ToList(),
            TopErrors = topErrors.ToList()
        };
    }

    /// <summary>
    /// Gets delivery statistics for a specific user
    /// </summary>
    /// <param name="userId">Target user ID</param>
    /// <param name="fromDate">Start date for statistics</param>
    /// <param name="toDate">End date for statistics</param>
    /// <returns>User-specific delivery statistics</returns>
    public async Task<UserDeliveryStats> GetUserDeliveryStatsAsync(int userId, DateTime fromDate, DateTime toDate)
    {
        const string sql = @"
            SELECT 
                COUNT(*) as TotalNotifications,
                COUNT(CASE WHEN nh.DeliveryStatus = @DeliveredStatus THEN 1 END) as DeliveredNotifications,
                COUNT(CASE WHEN nh.DeliveryStatus = @FailedStatus THEN 1 END) as FailedNotifications,
                COUNT(CASE WHEN n.IsRead = 1 THEN 1 END) as ReadNotifications,
                AVG(CASE WHEN nh.DeliveredAt IS NOT NULL AND nh.AttemptedAt IS NOT NULL 
                    THEN (julianday(nh.DeliveredAt) - julianday(nh.AttemptedAt)) * 86400 END) as AvgDeliveryTimeSeconds
            FROM NotificationHistory nh
            INNER JOIN Notifications n ON nh.NotificationId = n.Id
            WHERE n.UserId = @UserId 
                AND nh.AttemptedAt BETWEEN @FromDate AND @ToDate 
                AND nh.IsDeleted = 0 
                AND n.IsDeleted = 0";

        const string byChannelSql = @"
            SELECT 
                nh.Channel,
                COUNT(*) as Count
            FROM NotificationHistory nh
            INNER JOIN Notifications n ON nh.NotificationId = n.Id
            WHERE n.UserId = @UserId 
                AND nh.AttemptedAt BETWEEN @FromDate AND @ToDate 
                AND nh.DeliveryStatus = @DeliveredStatus
                AND nh.IsDeleted = 0 
                AND n.IsDeleted = 0
            GROUP BY nh.Channel";

        var parameters = new 
        { 
            UserId = userId,
            FromDate = fromDate,
            ToDate = toDate,
            DeliveredStatus = NotificationDeliveryStatus.Delivered,
            FailedStatus = NotificationDeliveryStatus.Failed
        };

        using var connection = _connectionFactory.CreateConnection();

        var stats = await connection.QueryFirstOrDefaultAsync<UserDeliveryStats>(sql, parameters);
        var byChannel = await connection.QueryAsync<(NotificationChannel Channel, int Count)>(byChannelSql, parameters);

        if (stats != null)
        {
            foreach (var (channel, count) in byChannel)
            {
                stats.DeliveryByChannel[channel] = count;
            }
        }

        return stats ?? new UserDeliveryStats { UserId = userId };
    }

    /// <summary>
    /// Bulk creates delivery history records
    /// </summary>
    /// <param name="historyRecords">List of history records to create</param>
    /// <returns>Number of records created</returns>
    public async Task<int> BulkCreateAsync(IEnumerable<NotificationHistory> historyRecords)
    {
        const string sql = @"
            INSERT INTO NotificationHistory (
                Id, NotificationId, Channel, Provider, AttemptedAt, DeliveredAt,
                DeliveryStatus, ErrorMessage, RetryCount, Cost, CostCurrency, Metadata,
                OpenedAt, ClickedAt, Priority, ExternalId, ResponseData,
                CreatedAt, ModifiedAt, IsDeleted
            ) VALUES (
                @Id, @NotificationId, @Channel, @Provider, @AttemptedAt, @DeliveredAt,
                @DeliveryStatus, @ErrorMessage, @RetryCount, @Cost, @CostCurrency, @Metadata,
                @OpenedAt, @ClickedAt, @Priority, @ExternalId, @ResponseData,
                @CreatedAt, @ModifiedAt, @IsDeleted
            )";

        using var connection = _connectionFactory.CreateConnection();
        using var transaction = connection.BeginTransaction();

        try
        {
            var now = DateTime.UtcNow;
            var recordsWithDefaults = historyRecords.Select(h =>
            {
                h.Id = h.Id == Guid.Empty ? Guid.NewGuid() : h.Id;
                h.CreatedAt = now;
                h.ModifiedAt = now;
                h.IsDeleted = false;
                return h;
            });

            var affectedRows = await connection.ExecuteAsync(sql, recordsWithDefaults, transaction);
            transaction.Commit();
            return affectedRows;
        }
        catch
        {
            transaction.Rollback();
            throw;
        }
    }

    /// <summary>
    /// Deletes old delivery history records beyond retention period
    /// </summary>
    /// <param name="retentionDays">Number of days to retain delivery history</param>
    /// <returns>Number of records deleted</returns>
    public async Task<int> CleanupOldHistoryAsync(int retentionDays = 365)
    {
        const string sql = @"
            UPDATE NotificationHistory 
            SET IsDeleted = 1, ModifiedAt = @ModifiedAt
            WHERE AttemptedAt < @CutoffDate 
                AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        return await connection.ExecuteAsync(sql, new 
        { 
            CutoffDate = DateTime.UtcNow.AddDays(-retentionDays),
            ModifiedAt = DateTime.UtcNow
        });
    }

    /// <summary>
    /// Gets delivery performance metrics for monitoring
    /// </summary>
    /// <param name="minutesBack">Number of minutes to look back for metrics</param>
    /// <returns>Recent delivery performance metrics</returns>
    public async Task<DeliveryPerformanceMetrics> GetRecentPerformanceMetricsAsync(int minutesBack = 60)
    {
        const string sql = @"
            SELECT 
                Channel,
                COUNT(*) as TotalAttempts,
                COUNT(CASE WHEN DeliveryStatus = @DeliveredStatus THEN 1 END) as SuccessfulDeliveries,
                COUNT(CASE WHEN DeliveryStatus = @FailedStatus THEN 1 END) as FailedDeliveries,
                AVG(CASE WHEN DeliveredAt IS NOT NULL AND AttemptedAt IS NOT NULL 
                    THEN (julianday(DeliveredAt) - julianday(AttemptedAt)) * 86400 END) as AvgDeliveryTimeSeconds,
                MAX(CASE WHEN DeliveredAt IS NOT NULL AND AttemptedAt IS NOT NULL 
                    THEN (julianday(DeliveredAt) - julianday(AttemptedAt)) * 86400 END) as MaxDeliveryTimeSeconds
            FROM NotificationHistory 
            WHERE AttemptedAt >= @FromTime 
                AND IsDeleted = 0
            GROUP BY Channel";

        using var connection = _connectionFactory.CreateConnection();
        var metrics = await connection.QueryAsync<ChannelPerformanceMetrics>(sql, new 
        { 
            FromTime = DateTime.UtcNow.AddMinutes(-minutesBack),
            DeliveredStatus = NotificationDeliveryStatus.Delivered,
            FailedStatus = NotificationDeliveryStatus.Failed
        });

        return new DeliveryPerformanceMetrics
        {
            MetricsTime = DateTime.UtcNow,
            PeriodMinutes = minutesBack,
            ChannelMetrics = metrics.ToList()
        };
    }

    /// <summary>
    /// Records a delivery attempt
    /// </summary>
    public async Task<NotificationHistory> RecordDeliveryAttemptAsync(
        Guid notificationId,
        NotificationChannel channel,
        NotificationDeliveryStatus status,
        string? errorMessage = null,
        string? externalId = null,
        string? responseData = null,
        decimal? cost = null,
        string? costCurrency = null)
    {
        var history = new NotificationHistory
        {
            Id = Guid.NewGuid(),
            NotificationId = notificationId,
            Channel = channel,
            Provider = null,
            DeliveryStatus = status,
            AttemptedAt = DateTime.UtcNow,
            DeliveredAt = null,
            ErrorMessage = errorMessage,
            ExternalId = externalId,
            ResponseData = responseData,
            RetryCount = 0,
            Cost = cost,
            CostCurrency = costCurrency ?? "USD",
            Metadata = null,
            Priority = (int)channel, // Setting priority based on channel for delivery order
            CreatedAt = DateTime.UtcNow,
            ModifiedAt = DateTime.UtcNow,
            IsDeleted = false
        };

        return await AddAsync(history);
    }

    /// <summary>
    /// Records notification opened event
    /// </summary>
    public async Task<bool> RecordOpenedAsync(string externalId, DateTime? openedAt = null)
    {
        const string sql = @"
            UPDATE NotificationHistory 
            SET OpenedAt = @OpenedAt, 
                ModifiedAt = @ModifiedAt
            WHERE ExternalId = @ExternalId 
                AND OpenedAt IS NULL 
                AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        var affectedRows = await connection.ExecuteAsync(sql, new 
        { 
            ExternalId = externalId,
            OpenedAt = openedAt ?? DateTime.UtcNow,
            ModifiedAt = DateTime.UtcNow
        });

        return affectedRows > 0;
    }

    /// <summary>
    /// Records notification clicked event
    /// </summary>
    public async Task<bool> RecordClickedAsync(string externalId, DateTime? clickedAt = null)
    {
        const string sql = @"
            UPDATE NotificationHistory 
            SET ClickedAt = @ClickedAt, 
                ModifiedAt = @ModifiedAt
            WHERE ExternalId = @ExternalId 
                AND ClickedAt IS NULL 
                AND IsDeleted = 0";

        using var connection = _connectionFactory.CreateConnection();
        var affectedRows = await connection.ExecuteAsync(sql, new 
        { 
            ExternalId = externalId,
            ClickedAt = clickedAt ?? DateTime.UtcNow,
            ModifiedAt = DateTime.UtcNow
        });

        return affectedRows > 0;
    }

    /// <summary>
    /// Gets delivery statistics for a date range
    /// </summary>
    public async Task<Ikhtibar.Core.Repositories.Interfaces.DeliveryStats> GetDeliveryStatsAsync(
        DateTime fromDate,
        DateTime toDate,
        NotificationChannel? channel = null)
    {
        var whereClause = "IsDeleted = 0 AND AttemptedAt BETWEEN @FromDate AND @ToDate";
        var parameters = new DynamicParameters();
        parameters.Add("@FromDate", fromDate);
        parameters.Add("@ToDate", toDate);

        if (channel.HasValue)
        {
            whereClause += " AND Channel = @Channel";
            parameters.Add("@Channel", channel.Value);
        }

        var statsSql = $@"
            SELECT 
                COUNT(1) as TotalAttempts,
                SUM(CASE WHEN Status = @DeliveredStatus THEN 1 ELSE 0 END) as SuccessfulDeliveries,
                SUM(CASE WHEN Status = @FailedStatus THEN 1 ELSE 0 END) as FailedDeliveries,
                SUM(CASE WHEN Status = @PendingStatus THEN 1 ELSE 0 END) as PendingDeliveries
            FROM NotificationHistory 
            WHERE {whereClause}";

        var channelSql = $@"
            SELECT Channel, COUNT(1) as Count
            FROM NotificationHistory 
            WHERE {whereClause}
            GROUP BY Channel";

        var statusSql = $@"
            SELECT Status, COUNT(1) as Count
            FROM NotificationHistory 
            WHERE {whereClause}
            GROUP BY Status";

        parameters.Add("@DeliveredStatus", NotificationDeliveryStatus.Delivered);
        parameters.Add("@FailedStatus", NotificationDeliveryStatus.Failed);
        parameters.Add("@PendingStatus", NotificationDeliveryStatus.Pending);

        using var connection = _connectionFactory.CreateConnection();

        var statsResult = await connection.QuerySingleAsync<(int TotalAttempts, int SuccessfulDeliveries, int FailedDeliveries, int PendingDeliveries)>(statsSql, parameters);
        var channelResults = await connection.QueryAsync<(NotificationChannel Channel, int Count)>(channelSql, parameters);
        var statusResults = await connection.QueryAsync<(NotificationDeliveryStatus Status, int Count)>(statusSql, parameters);

        var stats = new Ikhtibar.Core.Repositories.Interfaces.DeliveryStats
        {
            TotalAttempts = statsResult.TotalAttempts,
            SuccessfulDeliveries = statsResult.SuccessfulDeliveries,
            FailedDeliveries = statsResult.FailedDeliveries,
            PendingDeliveries = statsResult.PendingDeliveries,
            SuccessRate = statsResult.TotalAttempts > 0 ? (decimal)statsResult.SuccessfulDeliveries / statsResult.TotalAttempts * 100 : 0
        };

        foreach (var (ch, count) in channelResults)
        {
            stats.DeliveriesByChannel[ch] = count;
        }

        foreach (var (status, count) in statusResults)
        {
            stats.DeliveriesByStatus[status] = count;
        }

        return stats;
    }

    /// <summary>
    /// Gets delivery history with pagination and filtering
    /// </summary>
    public async Task<(IEnumerable<NotificationHistory> History, int TotalCount)> GetDeliveryHistoryAsync(
        int page = 1,
        int pageSize = 20,
        NotificationChannel? channel = null,
        NotificationDeliveryStatus? status = null,
        DateTime? fromDate = null,
        DateTime? toDate = null)
    {
        var offset = (page - 1) * pageSize;
        var whereConditions = "IsDeleted = 0";
        var parameters = new DynamicParameters();
        parameters.Add("@Offset", offset);
        parameters.Add("@PageSize", pageSize);

        if (channel.HasValue)
        {
            whereConditions += " AND Channel = @Channel";
            parameters.Add("@Channel", channel.Value);
        }

        if (status.HasValue)
        {
            whereConditions += " AND Status = @Status";
            parameters.Add("@Status", status.Value);
        }

        if (fromDate.HasValue)
        {
            whereConditions += " AND AttemptedAt >= @FromDate";
            parameters.Add("@FromDate", fromDate.Value);
        }

        if (toDate.HasValue)
        {
            whereConditions += " AND AttemptedAt <= @ToDate";
            parameters.Add("@ToDate", toDate.Value);
        }

        var countSql = $@"
            SELECT COUNT(1) 
            FROM NotificationHistory 
            WHERE {whereConditions}";

        var dataSql = $@"
            SELECT * 
            FROM NotificationHistory 
            WHERE {whereConditions}
            ORDER BY AttemptedAt DESC 
            OFFSET @offset ROWS FETCH NEXT @pageSize ROWS ONLY";

        using var connection = _connectionFactory.CreateConnection();

        var totalCount = await connection.QuerySingleAsync<int>(countSql, parameters);
        var history = await connection.QueryAsync<NotificationHistory>(dataSql, parameters);

        return (history, totalCount);
    }

    /// <summary>
    /// Gets cost analysis for delivered notifications
    /// </summary>
    public async Task<IEnumerable<Ikhtibar.Core.Repositories.Interfaces.CostAnalysis>> GetCostAnalysisAsync(
        DateTime fromDate,
        DateTime toDate,
        Ikhtibar.Core.Repositories.Interfaces.CostGrouping groupBy = Ikhtibar.Core.Repositories.Interfaces.CostGrouping.Channel)
    {
        var groupByClause = groupBy switch
        {
            Ikhtibar.Core.Repositories.Interfaces.CostGrouping.Channel => "Channel",
            Ikhtibar.Core.Repositories.Interfaces.CostGrouping.Day => "DATE(AttemptedAt)",
            Ikhtibar.Core.Repositories.Interfaces.CostGrouping.Month => "DATE_FORMAT(AttemptedAt, '%Y-%m')",
            Ikhtibar.Core.Repositories.Interfaces.CostGrouping.NotificationType => "JSON_EXTRACT(ResponseData, '$.notificationType')",
            _ => "Channel"
        };

        var sql = $@"
            SELECT 
                {groupByClause} as GroupKey,
                COALESCE(SUM(Cost), 0) as TotalCost,
                COALESCE(MAX(CostCurrency), 'USD') as Currency,
                COUNT(1) as DeliveryCount,
                COALESCE(AVG(Cost), 0) as AverageCost
            FROM NotificationHistory 
            WHERE IsDeleted = 0 
                AND AttemptedAt BETWEEN @FromDate AND @ToDate
                AND Cost IS NOT NULL
                AND Status = @DeliveredStatus
            GROUP BY {groupByClause}
            ORDER BY TotalCost DESC";

        using var connection = _connectionFactory.CreateConnection();
        var results = await connection.QueryAsync<Ikhtibar.Core.Repositories.Interfaces.CostAnalysis>(sql, new 
        { 
            FromDate = fromDate,
            ToDate = toDate,
            DeliveredStatus = NotificationDeliveryStatus.Delivered
        });

        return results;
    }
}

/// <summary>
/// Delivery analytics model
/// </summary>
public class DeliveryAnalytics
{
    public DateTime PeriodStart { get; set; }
    public DateTime PeriodEnd { get; set; }
    public OverallDeliveryStats Overall { get; set; } = new();
    public List<ChannelDeliveryStats> ByChannel { get; set; } = new();
    public List<HourlyDeliveryStats> ByHour { get; set; } = new();
    public List<ErrorStats> TopErrors { get; set; } = new();
}

/// <summary>
/// Overall delivery statistics
/// </summary>
public class OverallDeliveryStats
{
    public int TotalAttempts { get; set; }
    public int SuccessfulDeliveries { get; set; }
    public int FailedDeliveries { get; set; }
    public int PendingDeliveries { get; set; }
    public double AvgDeliveryTimeSeconds { get; set; }
    public decimal TotalCost { get; set; }
    public double DeliveryRate => TotalAttempts > 0 ? (double)SuccessfulDeliveries / TotalAttempts * 100 : 0;
}

/// <summary>
/// Channel-specific delivery statistics
/// </summary>
public class ChannelDeliveryStats
{
    public NotificationChannel Channel { get; set; }
    public int TotalAttempts { get; set; }
    public int SuccessfulDeliveries { get; set; }
    public int FailedDeliveries { get; set; }
    public double AvgDeliveryTimeSeconds { get; set; }
    public decimal TotalCost { get; set; }
    public double DeliveryRate => TotalAttempts > 0 ? (double)SuccessfulDeliveries / TotalAttempts * 100 : 0;
}

/// <summary>
/// Hourly delivery statistics
/// </summary>
public class HourlyDeliveryStats
{
    public string Hour { get; set; } = string.Empty;
    public int TotalAttempts { get; set; }
    public int SuccessfulDeliveries { get; set; }
}

/// <summary>
/// Error statistics
/// </summary>
public class ErrorStats
{
    public string ErrorMessage { get; set; } = string.Empty;
    public int ErrorCount { get; set; }
    public NotificationChannel Channel { get; set; }
}

/// <summary>
/// User-specific delivery statistics
/// </summary>
public class UserDeliveryStats
{
    public int UserId { get; set; }
    public int TotalNotifications { get; set; }
    public int DeliveredNotifications { get; set; }
    public int FailedNotifications { get; set; }
    public int ReadNotifications { get; set; }
    public double AvgDeliveryTimeSeconds { get; set; }
    public Dictionary<NotificationChannel, int> DeliveryByChannel { get; set; } = new();
}

/// <summary>
/// Delivery performance metrics for monitoring
/// </summary>
public class DeliveryPerformanceMetrics
{
    public DateTime MetricsTime { get; set; }
    public int PeriodMinutes { get; set; }
    public List<ChannelPerformanceMetrics> ChannelMetrics { get; set; } = new();
}

/// <summary>
/// Channel performance metrics
/// </summary>
public class ChannelPerformanceMetrics
{
    public NotificationChannel Channel { get; set; }
    public int TotalAttempts { get; set; }
    public int SuccessfulDeliveries { get; set; }
    public int FailedDeliveries { get; set; }
    public double AvgDeliveryTimeSeconds { get; set; }
    public double MaxDeliveryTimeSeconds { get; set; }
    public double DeliveryRate => TotalAttempts > 0 ? (double)SuccessfulDeliveries / TotalAttempts * 100 : 0;
}
