using Dapper;
using Ikhtibar.Core.Entities;
using Ikhtibar.Core.Repositories.Interfaces;
using Ikhtibar.Infrastructure.Data;
using Microsoft.Extensions.Logging;
using System.Text;
using MediaType = Ikhtibar.Core.Entities.MediaType;
using MediaStatus = Ikhtibar.Core.Entities.MediaStatus;

namespace Ikhtibar.Infrastructure.Repositories;

/// <summary>
/// Repository implementation for MediaFile entity operations using Dapper
/// Provides specialized methods for media file management with optimized queries
/// </summary>
public class MediaFileRepository : BaseRepository<MediaFile>, IMediaFileRepository
{
    private readonly ILogger<MediaFileRepository> _logger;

    public MediaFileRepository(IDbConnectionFactory connectionFactory, ILogger<MediaFileRepository> logger)
        : base(connectionFactory)
    {
        _logger = logger;
    }

    /// <summary>
    /// Gets media files by category
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetByCategoryAsync(Guid categoryId, bool includeSubcategories = false)
    {
        using var scope = _logger.BeginScope("Getting media files by category {CategoryId}, includeSubcategories: {IncludeSubcategories}", categoryId, includeSubcategories);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            string sql;
            if (includeSubcategories)
            {
                sql = @"
                    WITH CategoryHierarchy AS (
                        SELECT Id FROM MediaCategories WHERE Id = @CategoryId
                        UNION ALL
                        SELECT c.Id FROM MediaCategories c
                        INNER JOIN CategoryHierarchy ch ON c.ParentCategoryId = ch.Id
                    )
                    SELECT m.* FROM MediaFiles m
                    INNER JOIN CategoryHierarchy ch ON m.CategoryId = ch.Id
                    WHERE m.IsDeleted = 0
                    ORDER BY m.CreatedAt DESC";
            }
            else
            {
                sql = @"
                    SELECT * FROM MediaFiles 
                    WHERE CategoryId = @CategoryId AND IsDeleted = 0
                    ORDER BY CreatedAt DESC";
            }
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { CategoryId = categoryId });
            
            _logger.LogInformation("Retrieved {Count} media files for category {CategoryId}", result.Count(), categoryId);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media files by category {CategoryId}", categoryId);
            throw;
        }
    }

    /// <summary>
    /// Gets media files by type with pagination
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetByTypeAsync(MediaType mediaType, int offset = 0, int limit = 50, string? orderBy = null)
    {
        using var scope = _logger.BeginScope("Getting media files by type {MediaType}", mediaType);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var orderClause = string.IsNullOrEmpty(orderBy) ? "ORDER BY CreatedAt DESC" : $"ORDER BY {orderBy}";
            
            var sql = $@"
                SELECT * FROM MediaFiles 
                WHERE MediaType = @MediaType AND IsDeleted = 0
                {orderClause}
                OFFSET @Offset ROWS FETCH NEXT @Limit ROWS ONLY";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new
            {
                MediaType = mediaType,
                Offset = offset,
                Limit = limit
            });
            
            _logger.LogInformation("Retrieved {Count} media files for type {MediaType}", result.Count(), mediaType);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media files by type {MediaType}", mediaType);
            throw;
        }
    }

    /// <summary>
    /// Gets media files by status
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetByStatusAsync(MediaStatus status)
    {
        using var scope = _logger.BeginScope("Getting media files by status {Status}", status);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT * FROM MediaFiles 
                WHERE Status = @Status AND IsDeleted = 0
                ORDER BY CreatedAt DESC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { Status = status });
            
            _logger.LogInformation("Retrieved {Count} media files with status {Status}", result.Count(), status);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media files by status {Status}", status);
            throw;
        }
    }

    /// <summary>
    /// Gets media files uploaded by a specific user
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetByUserAsync(Guid userId, int offset = 0, int limit = 50)
    {
        using var scope = _logger.BeginScope("Getting media files by user {UserId}", userId);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT * FROM MediaFiles 
                WHERE UploadedByUserId = @UserId AND IsDeleted = 0
                ORDER BY CreatedAt DESC
                OFFSET @Offset ROWS FETCH NEXT @Limit ROWS ONLY";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new
            {
                UserId = userId,
                Offset = offset,
                Limit = limit
            });
            
            _logger.LogInformation("Retrieved {Count} media files for user {UserId}", result.Count(), userId);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media files by user {UserId}", userId);
            throw;
        }
    }

    /// <summary>
    /// Searches media files by filename, title, or description
    /// </summary>
    public async Task<IEnumerable<MediaFile>> SearchAsync(string searchTerm, MediaType? mediaType = null, Guid? categoryId = null, int offset = 0, int limit = 50)
    {
        using var scope = _logger.BeginScope("Searching media files with term {SearchTerm}", searchTerm);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = new StringBuilder(@"
                SELECT DISTINCT m.* FROM MediaFiles m
                LEFT JOIN MediaMetadata mm ON m.Id = mm.MediaFileId
                WHERE m.IsDeleted = 0 AND (
                    m.FileName LIKE @SearchTerm OR 
                    m.Title LIKE @SearchTerm OR 
                    m.Description LIKE @SearchTerm OR
                    mm.Value LIKE @SearchTerm
                )");
            
            var parameters = new DynamicParameters();
            parameters.Add("SearchTerm", $"%{searchTerm}%");
            
            if (mediaType.HasValue)
            {
                sql.Append(" AND m.MediaType = @MediaType");
                parameters.Add("MediaType", mediaType.Value);
            }
            
            if (categoryId.HasValue)
            {
                sql.Append(" AND m.CategoryId = @CategoryId");
                parameters.Add("CategoryId", categoryId.Value);
            }
            
            sql.Append(@"
                ORDER BY m.CreatedAt DESC
                OFFSET @Offset ROWS FETCH NEXT @Limit ROWS ONLY");
            
            parameters.Add("Offset", offset);
            parameters.Add("Limit", limit);
            
            var result = await connection.QueryAsync<MediaFile>(sql.ToString(), parameters);
            
            _logger.LogInformation("Found {Count} media files matching search term {SearchTerm}", result.Count(), searchTerm);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error searching media files with term {SearchTerm}", searchTerm);
            throw;
        }
    }

    /// <summary>
    /// Gets media files by file hash
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetByHashAsync(string fileHash)
    {
        using var scope = _logger.BeginScope("Getting media files by hash {FileHash}", fileHash);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT * FROM MediaFiles 
                WHERE FileHash = @FileHash AND IsDeleted = 0
                ORDER BY CreatedAt ASC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { FileHash = fileHash });
            
            _logger.LogInformation("Found {Count} media files with hash {FileHash}", result.Count(), fileHash);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting media files by hash {FileHash}", fileHash);
            throw;
        }
    }

    /// <summary>
    /// Gets media files by content type
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetByContentTypeAsync(string contentType)
    {
        using var scope = _logger.BeginScope("Getting media files by content type {ContentType}", contentType);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT * FROM MediaFiles 
                WHERE ContentType = @ContentType AND IsDeleted = 0
                ORDER BY CreatedAt DESC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { ContentType = contentType });
            
            _logger.LogInformation("Retrieved {Count} media files with content type {ContentType}", result.Count(), contentType);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media files by content type {ContentType}", contentType);
            throw;
        }
    }

    /// <summary>
    /// Gets recently uploaded media files
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetRecentAsync(int days = 7, int limit = 50)
    {
        using var scope = _logger.BeginScope("Getting recent uploads from last {Days} days", days);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT TOP(@Limit) * FROM MediaFiles 
                WHERE CreatedAt >= DATEADD(DAY, -@Days, GETUTCDATE()) AND IsDeleted = 0
                ORDER BY CreatedAt DESC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { Days = days, Limit = limit });
            
            _logger.LogInformation("Retrieved {Count} recent uploads from last {Days} days", result.Count(), days);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving recent uploads from last {Days} days", days);
            throw;
        }
    }

    /// <summary>
    /// Gets most accessed media files
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetMostAccessedAsync(int limit = 50)
    {
        using var scope = _logger.BeginScope("Getting most accessed media files");
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT TOP(@Limit) * FROM MediaFiles 
                WHERE IsDeleted = 0
                ORDER BY AccessCount DESC, LastAccessedAt DESC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { Limit = limit });
            
            _logger.LogInformation("Retrieved {Count} most accessed media files", result.Count());
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving most accessed media files");
            throw;
        }
    }

    /// <summary>
    /// Gets media files that need processing
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetPendingProcessingAsync(int limit = 100)
    {
        using var scope = _logger.BeginScope("Getting media files pending processing");
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT TOP(@Limit) * FROM MediaFiles 
                WHERE Status = @PendingStatus AND IsDeleted = 0
                ORDER BY CreatedAt ASC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { PendingStatus = MediaStatus.Processing, Limit = limit });
            
            _logger.LogInformation("Retrieved {Count} media files pending processing", result.Count());
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media files pending processing");
            throw;
        }
    }

    /// <summary>
    /// Gets media files larger than specified size
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetLargerThanAsync(long sizeBytes)
    {
        using var scope = _logger.BeginScope("Getting media files larger than {SizeBytes} bytes", sizeBytes);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT * FROM MediaFiles 
                WHERE FileSizeBytes > @SizeBytes AND IsDeleted = 0
                ORDER BY FileSizeBytes DESC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { SizeBytes = sizeBytes });
            
            _logger.LogInformation("Retrieved {Count} media files larger than {SizeBytes} bytes", result.Count(), sizeBytes);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media files larger than {SizeBytes} bytes", sizeBytes);
            throw;
        }
    }

    /// <summary>
    /// Gets storage statistics grouped by media type
    /// </summary>
    public async Task<Dictionary<MediaType, long>> GetStorageStatsByTypeAsync()
    {
        using var scope = _logger.BeginScope("Getting storage statistics by media type");
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT MediaType, SUM(FileSizeBytes) as TotalSize
                FROM MediaFiles 
                WHERE IsDeleted = 0
                GROUP BY MediaType";
            
            var result = await connection.QueryAsync<(MediaType MediaType, long TotalSize)>(sql);
            
            var stats = result.ToDictionary(x => x.MediaType, x => x.TotalSize);
            
            _logger.LogInformation("Retrieved storage statistics for {TypeCount} media types", stats.Count);
            return stats;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving storage statistics by media type");
            throw;
        }
    }

    /// <summary>
    /// Gets storage statistics grouped by category
    /// </summary>
    public async Task<Dictionary<Guid, long>> GetStorageStatsByCategoryAsync()
    {
        using var scope = _logger.BeginScope("Getting storage statistics by category");
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT CategoryId, SUM(FileSizeBytes) as TotalSize
                FROM MediaFiles 
                WHERE IsDeleted = 0 AND CategoryId IS NOT NULL
                GROUP BY CategoryId";
            
            var result = await connection.QueryAsync<(Guid CategoryId, long TotalSize)>(sql);
            
            var stats = result.ToDictionary(x => x.CategoryId, x => x.TotalSize);
            
            _logger.LogInformation("Retrieved storage statistics for {CategoryCount} categories", stats.Count);
            return stats;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving storage statistics by category");
            throw;
        }
    }

    /// <summary>
    /// Updates the access count and last accessed time
    /// </summary>
    public async Task<bool> UpdateAccessInfoAsync(Guid mediaFileId)
    {
        using var scope = _logger.BeginScope("Updating access info for media file {MediaFileId}", mediaFileId);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                UPDATE MediaFiles 
                SET AccessCount = ISNULL(AccessCount, 0) + 1, 
                    LastAccessedAt = GETUTCDATE(),
                    ModifiedAt = GETUTCDATE()
                WHERE Id = @MediaFileId AND IsDeleted = 0";
            
            var result = await connection.ExecuteAsync(sql, new { MediaFileId = mediaFileId });
            
            var success = result > 0;
            _logger.LogInformation("Updated access info for media file {MediaFileId}: {Success}", mediaFileId, success);
            return success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating access info for media file {MediaFileId}", mediaFileId);
            throw;
        }
    }

    /// <summary>
    /// Updates the media file status
    /// </summary>
    public async Task<bool> UpdateStatusAsync(Guid mediaFileId, MediaStatus status)
    {
        using var scope = _logger.BeginScope("Updating status to {Status} for media file {MediaFileId}", status, mediaFileId);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                UPDATE MediaFiles 
                SET Status = @Status, ModifiedAt = GETUTCDATE()
                WHERE Id = @MediaFileId AND IsDeleted = 0";
            
            var result = await connection.ExecuteAsync(sql, new { Status = status, MediaFileId = mediaFileId });
            
            var success = result > 0;
            _logger.LogInformation("Updated status to {Status} for media file {MediaFileId}: {Success}", status, mediaFileId, success);
            return success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating status to {Status} for media file {MediaFileId}", status, mediaFileId);
            throw;
        }
    }

    /// <summary>
    /// Bulk updates media file status
    /// </summary>
    public async Task<int> BulkUpdateStatusAsync(IEnumerable<Guid> mediaFileIds, MediaStatus status)
    {
        using var scope = _logger.BeginScope("Bulk updating status to {Status} for {Count} media files", status, mediaFileIds.Count());
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                UPDATE MediaFiles 
                SET Status = @Status, ModifiedAt = GETUTCDATE()
                WHERE Id IN @MediaFileIds AND IsDeleted = 0";
            
            var result = await connection.ExecuteAsync(sql, new { Status = status, MediaFileIds = mediaFileIds });
            
            _logger.LogInformation("Updated status to {Status} for {UpdatedCount} media files", status, result);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error bulk updating status to {Status}", status);
            throw;
        }
    }

    /// <summary>
    /// Gets media files that haven't been accessed recently
    /// </summary>
    public async Task<IEnumerable<MediaFile>> GetInactiveAsync(int days = 365, int limit = 1000)
    {
        using var scope = _logger.BeginScope("Getting inactive media files (>{Days} days, limit {Limit})", days, limit);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT TOP(@Limit) * FROM MediaFiles 
                WHERE (LastAccessedAt IS NULL OR LastAccessedAt < DATEADD(DAY, -@Days, GETUTCDATE()))
                  AND IsDeleted = 0
                ORDER BY LastAccessedAt ASC, CreatedAt ASC";
            
            var result = await connection.QueryAsync<MediaFile>(sql, new { Days = days, Limit = limit });
            
            _logger.LogInformation("Retrieved {Count} inactive media files", result.Count());
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving inactive media files");
            throw;
        }
    }

    /// <summary>
    /// Checks if a file with the same hash already exists
    /// </summary>
    public async Task<bool> IsDuplicateAsync(string fileHash, Guid? excludeId = null)
    {
        using var scope = _logger.BeginScope("Checking if file is duplicate by hash {FileHash}", fileHash);
        
        try
        {
            using var connection = await _connectionFactory.CreateConnectionAsync();
            
            var sql = @"
                SELECT COUNT(1) 
                FROM MediaFiles 
                WHERE FileHash = @FileHash AND IsDeleted = 0";
            
            var parameters = new DynamicParameters();
            parameters.Add("FileHash", fileHash);
            
            if (excludeId.HasValue)
            {
                sql += " AND Id != @ExcludeId";
                parameters.Add("ExcludeId", excludeId.Value);
            }
            
            var count = await connection.QuerySingleAsync<int>(sql, parameters);
            var isDuplicate = count > 0;
            
            _logger.LogInformation("File is duplicate by hash {FileHash}: {IsDuplicate}", fileHash, isDuplicate);
            return isDuplicate;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking if file is duplicate by hash {FileHash}", fileHash);
            throw;
        }
    }
}
