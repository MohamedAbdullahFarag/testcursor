using Microsoft.Extensions.Logging;
using Moq;
using Xunit.Framework;
using Ikhtibar.Core.Services.Implementations;
using Ikhtibar.Core.Services.Interfaces;
using Ikhtibar.Core.Repositories.Interfaces;
using Ikhtibar.Shared.Entities;
using Ikhtibar.Shared.DTOs;
using Ikhtibar.Shared.DTOs.Authentication;

namespace Ikhtibar.Tests.Core.Services
{
    [TestFixture]
    public class AuthenticationServiceTests
    {
        private readonly Mock<IUserRepository> _mockUserRepository;
        private readonly Mock<ITokenService> _mockTokenService;
        private readonly Mock<IOidcService> _mockOidcService;
        private readonly Mock<IRefreshTokenRepository> _mockRefreshTokenRepository;
        private readonly Mock<ILogger<AuthenticationService>> _mockLogger;
        private readonly AuthenticationService _authenticationService;

        public AuthenticationServiceTests()
        {
            _mockUserRepository = new Mock<IUserRepository>();
            _mockTokenService = new Mock<ITokenService>();
            _mockOidcService = new Mock<IOidcService>();
            _mockRefreshTokenRepository = new Mock<IRefreshTokenRepository>();
            _mockLogger = new Mock<ILogger<AuthenticationService>>();

            _authenticationService = new AuthenticationService(
                _mockUserRepository.Object,
                _mockTokenService.Object,
                _mockOidcService.Object,
                _mockRefreshTokenRepository.Object,
                _mockLogger.Object
            );
        }

        [SetUp]
        public void Setup()
        {
            // Reset all mock setups before each test
            _mockUserRepository.Reset();
            _mockTokenService.Reset();
            _mockOidcService.Reset();
            _mockRefreshTokenRepository.Reset();
            _mockLogger.Reset();
        }

        [Test]
        public async Task AuthenticateAsync_WithValidCredentials_ReturnsSuccessResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "password123"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = true,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            var accessToken = "access_token_123";
            var refreshToken = "refresh_token_123";

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            _mockTokenService.Setup(x => x.GenerateJwtAsync(user))
                .ReturnsAsync(accessToken);

            _mockTokenService.Setup(x => x.GenerateRefreshTokenAsync())
                .ReturnsAsync(refreshToken);

            _mockRefreshTokenRepository.Setup(x => x.AddAsync(It.IsAny<RefreshTokens>()))
                .ReturnsAsync(1);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Success, Is.True);
            Assert.That(result.AccessToken, Is.EqualTo(accessToken));
            Assert.That(result.RefreshTokens, Is.EqualTo(refreshToken));
            Assert.That(result.User, Is.Not.Null);
            Assert.That(result.User.Email, Is.EqualTo(user.Email));
            Assert.That(result.User.FirstName, Is.EqualTo(user.FirstName));
            Assert.That(result.User.LastName, Is.EqualTo(user.LastName));
        }

        [Test]
        public async Task AuthenticateAsync_WithInvalidEmail_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "nonexistent@example.com",
                Password = "password123"
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync((User?)null);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Success, Is.False);
            Assert.That(result.ErrorMessage, Is.EqualTo("Invalid email or password"));
        }

        [Test]
        public async Task AuthenticateAsync_WithInvalidPassword_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "wrongpassword"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = true,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Success, Is.False);
            Assert.That(result.ErrorMessage, Is.EqualTo("Invalid email or password"));
        }

        [Test]
        public async Task AuthenticateAsync_WithInactiveUser_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "password123"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = false,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Success, Is.False);
            Assert.That(result.ErrorMessage, Is.EqualTo("Account is deactivated"));
        }

        [Test]
        public async Task AuthenticateAsync_WithUnverifiedEmail_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "password123"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = true,
                EmailVerified = false,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Success, Is.False);
            Assert.That(result.ErrorMessage, Is.EqualTo("Please verify your email address before logging in"));
        }

        [Test]
        public async Task RefreshTokenAsync_WithValidToken_ReturnsSuccessResult()
        {
            // Arrange
            var refreshToken = "valid_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            var storedToken = new RefreshTokens
            {
                UserId = 1,
                TokenHash = tokenHash,
                ExpiresAt = DateTime.UtcNow.AddDays(30),
                IssuedAt = DateTime.UtcNow
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                IsActive = true,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            var newAccessToken = "new_access_token";
            var newRefreshToken = "new_refresh_token";

            _mockRefreshTokenRepository.Setup(x => x.GetByTokenHashAsync(tokenHash))
                .ReturnsAsync(storedToken);

            _mockUserRepository.Setup(x => x.GetByIdAsync(storedToken.UserId))
                .ReturnsAsync(user);

            _mockTokenService.Setup(x => x.GenerateJwtAsync(user))
                .ReturnsAsync(newAccessToken);

            _mockTokenService.Setup(x => x.GenerateRefreshTokenAsync())
                .ReturnsAsync(newRefreshToken);

            _mockRefreshTokenRepository.Setup(x => x.RevokeByTokenHashAsync(tokenHash))
                .ReturnsAsync(true);

            _mockRefreshTokenRepository.Setup(x => x.AddAsync(It.IsAny<RefreshTokens>()))
                .ReturnsAsync(1);

            // Act
            var result = await _authenticationService.RefreshTokenAsync(refreshToken);

            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Success, Is.True);
            Assert.That(result.AccessToken, Is.EqualTo(newAccessToken));
            Assert.That(result.RefreshTokens, Is.EqualTo(newRefreshToken));
        }

        [Test]
        public async Task RefreshTokenAsync_WithExpiredToken_ReturnsFailureResult()
        {
            // Arrange
            var refreshToken = "expired_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            var storedToken = new RefreshTokens
            {
                UserId = 1,
                TokenHash = tokenHash,
                ExpiresAt = DateTime.UtcNow.AddDays(-1), // Expired
                IssuedAt = DateTime.UtcNow.AddDays(-30)
            };

            _mockRefreshTokenRepository.Setup(x => x.GetByTokenHashAsync(tokenHash))
                .ReturnsAsync(storedToken);

            // Act
            var result = await _authenticationService.RefreshTokenAsync(refreshToken);

            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Success, Is.False);
            Assert.That(result.ErrorMessage, Is.EqualTo("Refresh token has expired"));
        }

        [Test]
        public async Task ValidateTokenAsync_WithValidToken_ReturnsTrue()
        {
            // Arrange
            var accessToken = "valid_access_token";
            _mockTokenService.Setup(x => x.IsTokenValidAsync(accessToken))
                .ReturnsAsync(true);

            // Act
            var result = await _authenticationService.ValidateTokenAsync(accessToken);

            // Assert
            Assert.That(result, Is.True);
        }

        [Test]
        public async Task ValidateTokenAsync_WithInvalidToken_ReturnsFalse()
        {
            // Arrange
            var accessToken = "invalid_access_token";
            _mockTokenService.Setup(x => x.IsTokenValidAsync(accessToken))
                .ReturnsAsync(false);

            // Act
            var result = await _authenticationService.ValidateTokenAsync(accessToken);

            // Assert
            Assert.That(result, Is.False);
        }

        [Test]
        public async Task RevokeTokenAsync_WithValidToken_ReturnsTrue()
        {
            // Arrange
            var refreshToken = "valid_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            _mockRefreshTokenRepository.Setup(x => x.RevokeByTokenHashAsync(tokenHash))
                .ReturnsAsync(true);

            // Act
            var result = await _authenticationService.RevokeTokenAsync(refreshToken);

            // Assert
            Assert.That(result, Is.True);
        }

        [Test]
        public async Task RevokeTokenAsync_WithInvalidToken_ReturnsFalse()
        {
            // Arrange
            var refreshToken = "invalid_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            _mockRefreshTokenRepository.Setup(x => x.RevokeByTokenHashAsync(tokenHash))
                .ReturnsAsync(false);

            // Act
            var result = await _authenticationService.RevokeTokenAsync(refreshToken);

            // Assert
            Assert.That(result, Is.False);
        }
    }
}
