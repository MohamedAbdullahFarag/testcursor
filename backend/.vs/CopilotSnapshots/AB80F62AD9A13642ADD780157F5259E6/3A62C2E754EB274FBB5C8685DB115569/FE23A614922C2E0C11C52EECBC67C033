using Microsoft.Extensions.Logging;
using Moq;
using Xunit;
using Ikhtibar.Core.Services.Implementations;
using Ikhtibar.Core.Services.Interfaces;
using Ikhtibar.Core.Repositories.Interfaces;
using Ikhtibar.Shared.Entities;
using Ikhtibar.Shared.DTOs;
using Ikhtibar.Shared.DTOs.Authentication;

namespace Ikhtibar.Tests.Core.Services
{
    public class AuthenticationServiceTests
    {
        private readonly Mock<IUserRepository> _mockUserRepository;
        private readonly Mock<ITokenService> _mockTokenService;
        private readonly Mock<IOidcService> _mockOidcService;
        private readonly Mock<IRefreshTokenRepository> _mockRefreshTokenRepository;
        private readonly Mock<ILogger<AuthenticationService>> _mockLogger;
        private readonly AuthenticationService _authenticationService;

        public AuthenticationServiceTests()
        {
            _mockUserRepository = new Mock<IUserRepository>();
            _mockTokenService = new Mock<ITokenService>();
            _mockOidcService = new Mock<IOidcService>();
            _mockRefreshTokenRepository = new Mock<IRefreshTokenRepository>();
            _mockLogger = new Mock<ILogger<AuthenticationService>>();

            _authenticationService = new AuthenticationService(
                _mockUserRepository.Object,
                _mockTokenService.Object,
                _mockOidcService.Object,
                _mockRefreshTokenRepository.Object,
                _mockLogger.Object
            );
        }

        [Fact]
        public async Task AuthenticateAsync_WithValidCredentials_ReturnsSuccessResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "password123"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = true,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            var accessToken = "access_token_123";
            var refreshToken = "refresh_token_123";

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            _mockTokenService.Setup(x => x.GenerateJwtAsync(user))
                .ReturnsAsync(accessToken);

            _mockTokenService.Setup(x => x.GenerateRefreshTokenAsync())
                .ReturnsAsync(refreshToken);

            _mockRefreshTokenRepository.Setup(x => x.AddAsync(It.IsAny<RefreshTokens>()))
                .ReturnsAsync(1);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.NotNull(result);
            Assert.True(result.Success);
            Assert.Equal(accessToken, result.AccessToken);
            Assert.Equal(refreshToken, result.RefreshTokens);
            Assert.NotNull(result.User);
            Assert.Equal(user.Email, result.User.Email);
            Assert.Equal(user.FirstName, result.User.FirstName);
            Assert.Equal(user.LastName, result.User.LastName);
        }

        [Fact]
        public async Task AuthenticateAsync_WithInvalidEmail_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "nonexistent@example.com",
                Password = "password123"
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync((User?)null);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.NotNull(result);
            Assert.False(result.Success);
            Assert.Equal("Invalid email or password", result.ErrorMessage);
        }

        [Fact]
        public async Task AuthenticateAsync_WithInvalidPassword_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "wrongpassword"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = true,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.NotNull(result);
            Assert.False(result.Success);
            Assert.Equal("Invalid email or password", result.ErrorMessage);
        }

        [Fact]
        public async Task AuthenticateAsync_WithInactiveUser_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "password123"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = false,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.NotNull(result);
            Assert.False(result.Success);
            Assert.Equal("Account is deactivated", result.ErrorMessage);
        }

        [Fact]
        public async Task AuthenticateAsync_WithUnverifiedEmail_ReturnsFailureResult()
        {
            // Arrange
            var loginRequest = new LoginDto
            {
                Email = "test@example.com",
                Password = "password123"
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("password123"),
                IsActive = true,
                EmailVerified = false,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            _mockUserRepository.Setup(x => x.GetByEmailAsync(loginRequest.Email))
                .ReturnsAsync(user);

            // Act
            var result = await _authenticationService.AuthenticateAsync(loginRequest);

            // Assert
            Assert.NotNull(result);
            Assert.False(result.Success);
            Assert.Equal("Please verify your email address before logging in", result.ErrorMessage);
        }

        [Fact]
        public async Task RefreshTokenAsync_WithValidToken_ReturnsSuccessResult()
        {
            // Arrange
            var refreshToken = "valid_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            var storedToken = new RefreshTokens
            {
                UserId = 1,
                TokenHash = tokenHash,
                ExpiresAt = DateTime.UtcNow.AddDays(30),
                IssuedAt = DateTime.UtcNow
            };

            var user = new User
            {
                UserId = 1,
                Email = "test@example.com",
                FirstName = "Test",
                LastName = "User",
                Username = "testuser",
                IsActive = true,
                EmailVerified = true,
                CreatedAt = DateTime.UtcNow,
                ModifiedAt = DateTime.UtcNow
            };

            var newAccessToken = "new_access_token";
            var newRefreshToken = "new_refresh_token";

            _mockRefreshTokenRepository.Setup(x => x.GetByTokenHashAsync(tokenHash))
                .ReturnsAsync(storedToken);

            _mockUserRepository.Setup(x => x.GetByIdAsync(storedToken.UserId))
                .ReturnsAsync(user);

            _mockTokenService.Setup(x => x.GenerateJwtAsync(user))
                .ReturnsAsync(newAccessToken);

            _mockTokenService.Setup(x => x.GenerateRefreshTokenAsync())
                .ReturnsAsync(newRefreshToken);

            _mockRefreshTokenRepository.Setup(x => x.RevokeByTokenHashAsync(tokenHash))
                .ReturnsAsync(true);

            _mockRefreshTokenRepository.Setup(x => x.AddAsync(It.IsAny<RefreshTokens>()))
                .ReturnsAsync(1);

            // Act
            var result = await _authenticationService.RefreshTokenAsync(refreshToken);

            // Assert
            Assert.NotNull(result);
            Assert.True(result.Success);
            Assert.Equal(newAccessToken, result.AccessToken);
            Assert.Equal(newRefreshToken, result.RefreshTokens);
        }

        [Fact]
        public async Task RefreshTokenAsync_WithExpiredToken_ReturnsFailureResult()
        {
            // Arrange
            var refreshToken = "expired_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            var storedToken = new RefreshTokens
            {
                UserId = 1,
                TokenHash = tokenHash,
                ExpiresAt = DateTime.UtcNow.AddDays(-1), // Expired
                IssuedAt = DateTime.UtcNow.AddDays(-30)
            };

            _mockRefreshTokenRepository.Setup(x => x.GetByTokenHashAsync(tokenHash))
                .ReturnsAsync(storedToken);

            // Act
            var result = await _authenticationService.RefreshTokenAsync(refreshToken);

            // Assert
            Assert.NotNull(result);
            Assert.False(result.Success);
            Assert.Equal("Refresh token has expired", result.ErrorMessage);
        }

        [Fact]
        public async Task ValidateTokenAsync_WithValidToken_ReturnsTrue()
        {
            // Arrange
            var accessToken = "valid_access_token";
            _mockTokenService.Setup(x => x.IsTokenValidAsync(accessToken))
                .ReturnsAsync(true);

            // Act
            var result = await _authenticationService.ValidateTokenAsync(accessToken);

            // Assert
            Assert.True(result);
        }

        [Fact]
        public async Task ValidateTokenAsync_WithInvalidToken_ReturnsFalse()
        {
            // Arrange
            var accessToken = "invalid_access_token";
            _mockTokenService.Setup(x => x.IsTokenValidAsync(accessToken))
                .ReturnsAsync(false);

            // Act
            var result = await _authenticationService.ValidateTokenAsync(accessToken);

            // Assert
            Assert.False(result);
        }

        [Fact]
        public async Task RevokeTokenAsync_WithValidToken_ReturnsTrue()
        {
            // Arrange
            var refreshToken = "valid_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            _mockRefreshTokenRepository.Setup(x => x.RevokeByTokenHashAsync(tokenHash))
                .ReturnsAsync(true);

            // Act
            var result = await _authenticationService.RevokeTokenAsync(refreshToken);

            // Assert
            Assert.True(result);
        }

        [Fact]
        public async Task RevokeTokenAsync_WithInvalidToken_ReturnsFalse()
        {
            // Arrange
            var refreshToken = "invalid_refresh_token";
            var tokenHash = Convert.ToBase64String(
                System.Security.Cryptography.SHA256.Create()
                    .ComputeHash(System.Text.Encoding.UTF8.GetBytes(refreshToken))
            );

            _mockRefreshTokenRepository.Setup(x => x.RevokeByTokenHashAsync(tokenHash))
                .ReturnsAsync(false);

            // Act
            var result = await _authenticationService.RevokeTokenAsync(refreshToken);

            // Assert
            Assert.False(result);
        }
    }
}
