# PRP: User Management Audit Logging System Implementation

## 🎯 Purpose
Implement a comprehensive audit logging system for user management operations that tracks all significant user actions, maintains compliance requirements, provides security monitoring capabilities, and supports detailed reporting for accountability and forensic analysis.

## 🎯 What (User-Visible Behavior)
1. **Activity Tracking**: Automatic logging of all user actions including login/logout, role changes, user modifications, and system access
2. **Security Monitoring**: Real-time tracking of failed login attempts, account lockouts, and suspicious activities
3. **Audit Reports**: Comprehensive reporting interface for compliance officers and administrators
4. **Compliance Support**: Detailed audit trails meeting regulatory requirements with tamper-proof logging
5. **Forensic Analysis**: Searchable logs with filtering capabilities for incident investigation

### Success Criteria
- [ ] All user management operations are automatically logged with appropriate detail
- [ ] Security events (login failures, lockouts) are tracked and reported
- [ ] Audit logs are tamper-proof and maintain data integrity
- [ ] Compliance reporting is available with export capabilities
- [ ] Log retention policies are implemented and automated
- [ ] Search and filtering capabilities are functional across all log types

## 🔧 How (Implementation Requirements)

### Core Components Required

#### 1. AuditLog Entity (Database Layer)
```csharp
// Following existing LoginAttempt pattern but extended for all activities
public class AuditLog : BaseEntity
{
    public int AuditLogId { get; set; }           // Primary key
    public int? UserId { get; set; }              // FK to Users (nullable for system actions)
    public string UserIdentifier { get; set; }    // Email/Username for auditing
    public string Action { get; set; }            // What action was performed
    public string EntityType { get; set; }       // What type of entity was affected
    public string EntityId { get; set; }         // ID of affected entity
    public string Details { get; set; }          // JSON details of the action
    public string? OldValues { get; set; }       // JSON of previous values
    public string? NewValues { get; set; }       // JSON of new values
    public string IpAddress { get; set; }        // Client IP address
    public string UserAgent { get; set; }        // Browser/client info
    public string SessionId { get; set; }        // Session identifier
    public AuditSeverity Severity { get; set; }  // Critical, High, Medium, Low
    public AuditCategory Category { get; set; }  // Authentication, Authorization, Data, System
    public DateTime Timestamp { get; set; }      // When action occurred
    public bool IsSystemAction { get; set; }     // Generated by system vs user action
}

public enum AuditSeverity { Critical, High, Medium, Low }
public enum AuditCategory { Authentication, Authorization, UserManagement, DataAccess, System, Security }
```

#### 2. IAuditService Interface (Service Layer)
```csharp
public interface IAuditService
{
    Task LogAsync(AuditLogEntry entry);
    Task LogUserActionAsync(int? userId, string action, string entityType, string entityId, object? oldValues = null, object? newValues = null);
    Task LogSecurityEventAsync(string userIdentifier, string action, string details, AuditSeverity severity = AuditSeverity.High);
    Task LogSystemActionAsync(string action, string details, string entityType = "System", string? entityId = null);
    Task<PagedResult<AuditLogDto>> GetAuditLogsAsync(AuditLogFilter filter);
    Task<PagedResult<AuditLogDto>> GetUserAuditLogsAsync(int userId, AuditLogFilter filter);
    Task<IEnumerable<AuditLogDto>> GetSecurityEventsAsync(DateTime fromDate, DateTime toDate);
    Task<byte[]> ExportAuditLogsAsync(AuditLogFilter filter, ExportFormat format);
}
```

#### 3. AuditMiddleware (ASP.NET Core Middleware)
```csharp
public class AuditMiddleware
{
    // Automatically capture HTTP context for audit trails
    // Extract user information, IP addresses, user agents
    // Log request/response patterns for API calls
    // Handle correlation IDs for distributed tracing
}
```

#### 4. Frontend Audit Components
```typescript
// Components for viewing audit logs in admin interface
interface AuditLogViewProps {
  userId?: number;
  showSecurityEvents?: boolean;
  allowExport?: boolean;
}

// Hook for audit log management
export const useAuditLogs = (): UseAuditLogsReturn => {
  // Fetch, filter, search, and export audit logs
  // Real-time updates for security events
  // Pagination and performance optimization
};
```

### Database Schema Requirements

#### AuditLogs Table
```sql
CREATE TABLE dbo.AuditLogs (
    AuditLogId      INT            IDENTITY(1,1) NOT NULL PRIMARY KEY,
    UserId          INT            NULL,         -- FK to Users
    UserIdentifier  NVARCHAR(255)  NOT NULL,    -- Email/Username for audit trail
    Action          NVARCHAR(100)  NOT NULL,    -- Action performed
    EntityType      NVARCHAR(50)   NOT NULL,    -- Type of entity affected
    EntityId        NVARCHAR(50)   NULL,        -- ID of affected entity
    Details         NVARCHAR(MAX)  NULL,        -- JSON details
    OldValues       NVARCHAR(MAX)  NULL,        -- JSON of old values
    NewValues       NVARCHAR(MAX)  NULL,        -- JSON of new values
    IpAddress       NVARCHAR(45)   NULL,        -- Client IP
    UserAgent       NVARCHAR(500)  NULL,        -- Browser info
    SessionId       NVARCHAR(100)  NULL,        -- Session identifier
    Severity        TINYINT        NOT NULL DEFAULT(2), -- AuditSeverity enum
    Category        TINYINT        NOT NULL DEFAULT(0), -- AuditCategory enum
    Timestamp       DATETIME2      NOT NULL DEFAULT(SYSUTCDATETIME()),
    IsSystemAction  BIT            NOT NULL DEFAULT(0),
    CreatedAt       DATETIME2      NOT NULL DEFAULT(SYSUTCDATETIME()),
    IsDeleted       BIT            NOT NULL DEFAULT(0),
    
    CONSTRAINT FK_AuditLogs_Users FOREIGN KEY (UserId) REFERENCES dbo.Users(UserId)
);

-- Indexes for performance
CREATE INDEX IX_AuditLogs_UserId_Timestamp ON dbo.AuditLogs(UserId, Timestamp DESC);
CREATE INDEX IX_AuditLogs_Category_Severity ON dbo.AuditLogs(Category, Severity);
CREATE INDEX IX_AuditLogs_Timestamp ON dbo.AuditLogs(Timestamp DESC);
CREATE INDEX IX_AuditLogs_EntityType_EntityId ON dbo.AuditLogs(EntityType, EntityId);
```

### Integration Points

#### Service Layer Integration
```csharp
// Integrate audit logging into existing services
public class UserService : IUserService
{
    private readonly IAuditService _auditService;
    
    public async Task<UserDto> CreateUserAsync(CreateUserDto dto)
    {
        var user = await _userRepository.CreateAsync(mappedUser);
        
        // Audit the user creation
        await _auditService.LogUserActionAsync(
            currentUserId, 
            "CREATE_USER", 
            "User", 
            user.UserId.ToString(),
            oldValues: null,
            newValues: user
        );
        
        return mappedResult;
    }
}
```

#### Controller Integration
```csharp
[HttpPost]
public async Task<ActionResult<UserDto>> CreateUser(CreateUserDto dto)
{
    // Automatic audit logging through middleware and service layer
    var result = await _userService.CreateUserAsync(dto);
    return CreatedAtAction(nameof(GetUser), new { id = result.UserId }, result);
}
```

### Security and Compliance Features

#### 1. Tamper-Proof Logging
- Cryptographic hashing of log entries
- Digital signatures for critical events
- Immutable log storage (append-only)
- Integrity verification capabilities

#### 2. Data Retention Policies
```csharp
public interface IAuditRetentionService
{
    Task ArchiveOldLogsAsync(TimeSpan retentionPeriod);
    Task PurgeArchivedLogsAsync(TimeSpan archivalPeriod);
    Task VerifyLogIntegrityAsync();
}
```

#### 3. Compliance Reporting
- GDPR compliance reporting
- SOX audit trail generation
- Custom compliance export formats
- Automated compliance monitoring

## 🔄 Validation Loops (Execute These to Verify Implementation)

### Level 1: Database and Basic Functionality
```bash
# Backend build validation
cd backend/Ikhtibar.API
dotnet build
dotnet test

# Database migration validation
dotnet ef migrations add AddAuditLogging
dotnet ef database update

# Verify audit log table creation
sqlcmd -Q "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'AuditLogs'"
```

### Level 2: Service Layer Testing
```csharp
[Test]
public async Task AuditService_Should_LogUserAction_When_ValidDataProvided()
{
    // Arrange
    var auditService = new AuditService(_auditRepository, _mapper, _logger);
    var entry = new AuditLogEntry
    {
        UserId = 1,
        Action = "CREATE_USER",
        EntityType = "User",
        EntityId = "123",
        Details = "User creation test"
    };

    // Act
    await auditService.LogAsync(entry);

    // Assert
    var logs = await _auditRepository.GetByUserIdAsync(1);
    Assert.Single(logs);
    Assert.Equal("CREATE_USER", logs.First().Action);
}

[Test]
public async Task AuditService_Should_LogSecurityEvent_When_LoginFailure()
{
    // Arrange
    var auditService = new AuditService(_auditRepository, _mapper, _logger);

    // Act
    await auditService.LogSecurityEventAsync(
        "test@example.com", 
        "LOGIN_FAILED", 
        "Invalid password attempt",
        AuditSeverity.High
    );

    // Assert
    var securityEvents = await _auditRepository.GetSecurityEventsAsync(DateTime.UtcNow.AddMinutes(-1), DateTime.UtcNow);
    Assert.Single(securityEvents);
    Assert.Equal(AuditSeverity.High, securityEvents.First().Severity);
}
```

### Level 3: Integration Testing
```csharp
[Test]
public async Task UserController_Should_CreateAuditLog_When_CreatingUser()
{
    // Arrange
    var client = _factory.CreateClient();
    var createDto = new CreateUserDto { Email = "test@example.com", Username = "testuser" };

    // Act
    var response = await client.PostAsJsonAsync("/api/users", createDto);

    // Assert
    response.EnsureSuccessStatusCode();
    
    // Verify audit log was created
    var auditLogs = await _auditService.GetAuditLogsAsync(new AuditLogFilter { Action = "CREATE_USER" });
    Assert.Single(auditLogs.Items);
}
```

### Level 4: Frontend Component Testing
```typescript
describe('AuditLogViewer', () => {
  it('should display audit logs for a user', async () => {
    const mockAuditLogs = [
      {
        id: 1,
        action: 'LOGIN',
        timestamp: '2024-01-01T10:00:00Z',
        details: 'Successful login'
      }
    ];

    const { getByText, getByRole } = render(
      <AuditLogViewer userId={1} />
    );

    // Wait for data to load
    await waitFor(() => {
      expect(getByText('LOGIN')).toBeInTheDocument();
      expect(getByText('Successful login')).toBeInTheDocument();
    });
  });

  it('should filter logs by date range', async () => {
    const { getByLabelText, getByRole } = render(
      <AuditLogViewer />
    );

    const fromDate = getByLabelText('From Date');
    const toDate = getByLabelText('To Date');
    const filterButton = getByRole('button', { name: 'Filter' });

    fireEvent.change(fromDate, { target: { value: '2024-01-01' } });
    fireEvent.change(toDate, { target: { value: '2024-01-31' } });
    fireEvent.click(filterButton);

    // Verify filter was applied
    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('fromDate=2024-01-01')
      );
    });
  });
});
```

### Level 5: End-to-End Validation
```bash
# User creation with audit logging
curl -X POST https://localhost:7001/api/users \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"email":"audit-test@example.com","username":"audituser","firstName":"Audit","lastName":"Test"}'

# Verify audit log creation
curl -X GET "https://localhost:7001/api/audit-logs?action=CREATE_USER" \
  -H "Authorization: Bearer $TOKEN"

# Expected response:
# {
#   "items": [
#     {
#       "id": 1,
#       "action": "CREATE_USER",
#       "entityType": "User",
#       "details": "User created successfully",
#       "timestamp": "2024-01-01T10:00:00Z"
#     }
#   ],
#   "total": 1
# }
```

## 📊 Implementation Blueprint

### Phase 1: Database and Entity Setup
```csharp
// 1. Create AuditLog entity
public class AuditLog : BaseEntity
{
    // Entity definition with all required properties
    // Follow existing LoginAttempt pattern
    // Include proper data annotations and relationships
}

// 2. Add DbSet to context
public class IkhtibarDbContext : DbContext
{
    public DbSet<AuditLog> AuditLogs { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure AuditLog entity relationships and constraints
        modelBuilder.Entity<AuditLog>()
            .HasIndex(a => new { a.UserId, a.Timestamp })
            .HasDatabaseName("IX_AuditLogs_UserId_Timestamp");
    }
}
```

### Phase 2: Repository Implementation
```csharp
public interface IAuditLogRepository
{
    Task<AuditLog> CreateAsync(AuditLog auditLog);
    Task<PagedResult<AuditLog>> GetAuditLogsAsync(AuditLogFilter filter);
    Task<IEnumerable<AuditLog>> GetUserAuditLogsAsync(int userId, DateTime fromDate, DateTime toDate);
    Task<IEnumerable<AuditLog>> GetSecurityEventsAsync(DateTime fromDate, DateTime toDate);
    Task<bool> VerifyLogIntegrityAsync(int auditLogId);
}

public class AuditLogRepository : BaseRepository<AuditLog>, IAuditLogRepository
{
    // Following SRP: ONLY audit log data operations
    // NO business logic beyond data persistence
    // NO cross-entity operations
    // FOCUSED: All methods work toward audit log data management
}
```

### Phase 3: Service Layer Implementation
```csharp
public class AuditService : IAuditService
{
    private readonly IAuditLogRepository _auditLogRepository;
    private readonly ICurrentUserService _currentUserService;
    private readonly IHttpContextAccessor _httpContextAccessor;
    private readonly ILogger<AuditService> _logger;

    public async Task LogUserActionAsync(int? userId, string action, string entityType, string entityId, 
        object? oldValues = null, object? newValues = null)
    {
        var httpContext = _httpContextAccessor.HttpContext;
        
        var auditLog = new AuditLog
        {
            UserId = userId,
            UserIdentifier = await GetUserIdentifierAsync(userId),
            Action = action,
            EntityType = entityType,
            EntityId = entityId,
            Details = GenerateActionDetails(action, entityType, entityId),
            OldValues = oldValues != null ? JsonSerializer.Serialize(oldValues) : null,
            NewValues = newValues != null ? JsonSerializer.Serialize(newValues) : null,
            IpAddress = GetClientIpAddress(httpContext),
            UserAgent = httpContext?.Request.Headers["User-Agent"].ToString(),
            SessionId = httpContext?.Session.Id,
            Severity = DetermineActionSeverity(action),
            Category = DetermineActionCategory(action),
            Timestamp = DateTime.UtcNow,
            IsSystemAction = userId == null
        };

        await _auditLogRepository.CreateAsync(auditLog);
        _logger.LogInformation("Audit log created: {Action} for {EntityType} {EntityId}", action, entityType, entityId);
    }
}
```

### Phase 4: Middleware Integration
```csharp
public class AuditMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IAuditService _auditService;

    public async Task InvokeAsync(HttpContext context)
    {
        // Capture request details for audit trail
        var originalBodyStream = context.Response.Body;
        
        using var responseBody = new MemoryStream();
        context.Response.Body = responseBody;

        await _next(context);

        // Log API calls for audit purposes
        if (ShouldAuditRequest(context))
        {
            await LogApiCallAsync(context);
        }

        await responseBody.CopyToAsync(originalBodyStream);
    }
}
```

### Phase 5: Controller Integration
```csharp
[ApiController]
[Route("api/audit-logs")]
[Authorize(Roles = "system-admin,supervisor")]
public class AuditLogsController : ControllerBase
{
    private readonly IAuditService _auditService;

    [HttpGet]
    public async Task<ActionResult<PagedResult<AuditLogDto>>> GetAuditLogs([FromQuery] AuditLogFilter filter)
    {
        var result = await _auditService.GetAuditLogsAsync(filter);
        return Ok(result);
    }

    [HttpGet("user/{userId}")]
    public async Task<ActionResult<PagedResult<AuditLogDto>>> GetUserAuditLogs(int userId, [FromQuery] AuditLogFilter filter)
    {
        var result = await _auditService.GetUserAuditLogsAsync(userId, filter);
        return Ok(result);
    }

    [HttpGet("security-events")]
    public async Task<ActionResult<IEnumerable<AuditLogDto>>> GetSecurityEvents([FromQuery] DateTime fromDate, [FromQuery] DateTime toDate)
    {
        var result = await _auditService.GetSecurityEventsAsync(fromDate, toDate);
        return Ok(result);
    }

    [HttpPost("export")]
    public async Task<ActionResult> ExportAuditLogs([FromBody] AuditLogFilter filter, [FromQuery] ExportFormat format = ExportFormat.Excel)
    {
        var data = await _auditService.ExportAuditLogsAsync(filter, format);
        var contentType = format == ExportFormat.Excel ? "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" : "text/csv";
        var fileName = $"audit-logs-{DateTime.UtcNow:yyyy-MM-dd}.{(format == ExportFormat.Excel ? "xlsx" : "csv")}";
        
        return File(data, contentType, fileName);
    }
}
```

### Phase 6: Frontend Implementation
```typescript
// Hook for audit log management
export const useAuditLogs = (filter?: AuditLogFilter): UseAuditLogsReturn => {
  const [auditLogs, setAuditLogs] = useState<AuditLogDto[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchAuditLogs = useCallback(async (searchFilter: AuditLogFilter) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await auditService.getAuditLogs(searchFilter);
      setAuditLogs(result.items);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch audit logs');
    } finally {
      setLoading(false);
    }
  }, []);

  const exportAuditLogs = useCallback(async (exportFilter: AuditLogFilter, format: ExportFormat) => {
    try {
      const blob = await auditService.exportAuditLogs(exportFilter, format);
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `audit-logs-${new Date().toISOString().split('T')[0]}.${format}`;
      link.click();
      window.URL.revokeObjectURL(url);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to export audit logs');
    }
  }, []);

  return {
    auditLogs,
    loading,
    error,
    fetchAuditLogs,
    exportAuditLogs
  };
};

// Audit log viewer component
export const AuditLogViewer: React.FC<AuditLogViewerProps> = ({ 
  userId, 
  showSecurityEvents = false,
  allowExport = true 
}) => {
  const { auditLogs, loading, error, fetchAuditLogs, exportAuditLogs } = useAuditLogs();
  const [filter, setFilter] = useState<AuditLogFilter>({
    userId,
    category: showSecurityEvents ? AuditCategory.Security : undefined,
    fromDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
    toDate: new Date(),
    page: 1,
    pageSize: 50
  });

  return (
    <div className="audit-log-viewer">
      {/* Filter controls */}
      <AuditLogFilter 
        filter={filter} 
        onFilterChange={setFilter}
        onApplyFilter={() => fetchAuditLogs(filter)}
      />
      
      {/* Export functionality */}
      {allowExport && (
        <div className="export-controls">
          <button onClick={() => exportAuditLogs(filter, ExportFormat.Excel)}>
            Export to Excel
          </button>
          <button onClick={() => exportAuditLogs(filter, ExportFormat.CSV)}>
            Export to CSV
          </button>
        </div>
      )}
      
      {/* Audit log table */}
      <AuditLogTable 
        auditLogs={auditLogs}
        loading={loading}
        error={error}
      />
    </div>
  );
};
```

## 🚨 Critical Security Requirements

### 1. Data Protection
- Encrypt sensitive audit data at rest
- Secure transmission of audit logs
- Access controls for audit log viewing
- Data masking for sensitive information

### 2. Integrity Verification
```csharp
public interface ILogIntegrityService
{
    Task<string> GenerateLogHashAsync(AuditLog log);
    Task<bool> VerifyLogIntegrityAsync(AuditLog log);
    Task<IntegrityReport> VerifyAllLogsIntegrityAsync(DateTime fromDate, DateTime toDate);
}
```

### 3. Access Controls
- Role-based access to audit logs
- Separation of duties for compliance
- Audit log access audit trail
- Non-repudiation mechanisms

## 📋 Anti-Patterns to Avoid

```csharp
// ❌ DON'T: Mix audit logging with business logic
public class UserService
{
    public async Task<User> CreateUserAsync(CreateUserDto dto)
    {
        // ❌ Don't log audit details in business service
        // ❌ Don't include audit repository dependencies here
        // Use audit service through dependency injection
    }
}

// ❌ DON'T: Create god audit service
public class AuditService
{
    // ❌ Don't include user management logic
    // ❌ Don't include authentication logic
    // ❌ Don't include reporting business logic
    // FOCUS: Only audit logging operations
}

// ❌ DON'T: Log sensitive data in plain text
public async Task LogUserActionAsync(User user)
{
    var details = $"Password: {user.PasswordHash}"; // ❌ Never log passwords
    var details = $"SSN: {user.SSN}"; // ❌ Never log PII without encryption
}

// ❌ DON'T: Skip audit logging for system actions
public async Task SystemMaintenance()
{
    // ❌ System actions need audit trails too
    await _userRepository.BulkUpdateAsync(users);
    // ✅ Should log: await _auditService.LogSystemActionAsync("BULK_UPDATE", "System maintenance");
}

// ❌ DON'T: Store audit logs in same database as application data
// ✅ Use separate audit database or immutable storage
// ✅ Implement log forwarding to security information systems
```

## 🧪 Testing Strategy Checklist

- [ ] **Unit Tests**: Audit service methods, log generation, integrity verification
- [ ] **Integration Tests**: Database operations, middleware integration, API endpoints
- [ ] **Security Tests**: Access controls, data protection, integrity verification
- [ ] **Performance Tests**: High-volume logging, query performance, export operations
- [ ] **Compliance Tests**: Retention policies, audit trail completeness, regulatory compliance

## 🛡️ Compliance and Security Validation

- [ ] **GDPR Compliance**: Data subject rights, data retention, consent tracking
- [ ] **SOX Compliance**: Financial data access auditing, change tracking, approval workflows
- [ ] **Security Standards**: ISO 27001, NIST Cybersecurity Framework requirements
- [ ] **Industry Standards**: Healthcare (HIPAA), Education (FERPA) compliance where applicable
- [ ] **Tamper Protection**: Cryptographic integrity, immutable storage, access monitoring

## 📈 Performance Considerations

### Database Optimization
- Partitioning audit logs by date ranges
- Archival strategies for old logs
- Efficient indexing for common queries
- Read replica databases for reporting

### Application Performance
- Asynchronous audit logging to avoid blocking operations
- Batch processing for high-volume events
- Caching for frequently accessed audit data
- Rate limiting for audit log queries

### Monitoring and Alerting
- Real-time alerts for security events
- Performance monitoring for audit operations
- Storage capacity monitoring
- Compliance deadline tracking

---

**Integration Dependencies:**
- Authentication system (for user context)
- Role management (for access controls)
- User management services (for audit subjects)
- Database infrastructure (for audit storage)
- Notification system (for security alerts)

**Next PRPs:**
- Notification System (depends on audit events)
- Reporting System (consumes audit data)
- Compliance Management (uses audit trails)
